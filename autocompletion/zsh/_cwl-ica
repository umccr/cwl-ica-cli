#compdef cwl-ica

# Generated with perl module App::Spec v0.000

_cwl-ica() {
    local program=cwl-ica
    typeset -A opt_args
    local curcontext="$curcontext" state line context


        # ---- Command: 
        _arguments -s  \
            '1: :->cmd1' \
            '*: :->args' \
            && ret=0


        case $state in
        cmd1)
            _alternative 'args:cmd2:((add-category-to-tool\:"Add an existing category to an existing tool
" add-category-to-workflow\:"Add an existing category to an existing workflow
" add-linked-project\:"Add a linked project to another project
" add-maintainer-to-expression\:"Add a maintainter to a cwl expression
" add-maintainer-to-tool\:"Add a maintainter to a cwl tool
" add-maintainer-to-workflow\:"Add a maintainter to a cwl workflow
" add-tool-to-project\:"Add an existing tool to another project
" add-workflow-to-project\:"Add an existing workflow to another project
" append-typescript-directory-to-cwl-commandline-tool\:"Append a directory named '"'"'typescript-expressions'"'"' to a CWL commandline tool
" append-typescript-directory-to-cwl-expression-tool\:"Append a directory named '"'"'typescript-expressions'"'"' to a CWL expression tool
" append-typescript-directory-to-cwl-workflow\:"Append a directory named '"'"'typescript-expressions'"'"' to a cwl workflow
" category-init\:"Initialise a category in \${CWL_ICA_REPO_PATH}/config/category.yaml
" configure-repo\:"One-time command to point to the cwl-ica git repository
" configure-tenant\:"Create mapping of tenancy ids to tenancy names, convenience to save time typing out tenancy names.
Each project is linked to a tenancy id
" configure-user\:"Add a user to user.yaml
" copy-tool-submission-template\:"Copy a tool submission template for an upcoming tool run
" copy-workflow-submission-template\:"Copy a workflow submission template for an upcoming workflow run
" create-expression-from-template\:"Initialise an CWL expression from the cwl expression template
" create-schema-from-template\:"Initialise a CWL schema from the cwl schema template
" create-tool-from-template\:"Initialise a CWL tool from the cwl tool template
" create-tool-submission-template\:"Create a ICA input template and bash script for a tool
" create-typescript-expression-from-template\:"Initialise an typescript expression from the typescript expression template
" create-typescript-interface-from-cwl-schema\:"Given a cwl schema create a typescript interface in the same directory
" create-workflow-from-template\:"Initialise a CWL workflow from the cwl workflow template
" create-workflow-submission-template\:"Create a ICA input template and bash script for a workflow
" expression-init\:"Register an expression in \${CWL_ICA_REPO_PATH}/config/expression.yaml
" expression-sync\:"Sync an expression in \${CWL_ICA_REPO_PATH}/config/expression.yaml
" expression-validate\:"Validate a CWL expression
" get-workflow-step-ids\:"Get the step ids of a CWL workflow
" help\:"Print help and exit
" icav2-deploy-pipeline\:"Deploy a zipped workflow to ICAv2
" icav2-get-analysis-step-logs\:"Launch a pipeline analysis in ICAv2
" icav2-launch-pipeline-analysis\:"Launch a pipeline analysis in ICAv2
" icav2-list-analysis-steps\:"List steps of an analysis
" icav2-zip-workflow\:"Zip up a workflow ready to become a pipeline in ICAv2
" list-categories\:"List registered categories
" list-projects\:"List registered projects
" list-tenants\:"List registered tenants
" list-tool-runs\:"List registered tool runs for a CWL tool in a given project
" list-users\:"List registered users
" list-workflow-runs\:"List registered workflows runs for a CWL workflow in a given project
" project-init\:"Initialise a project in \${CWL_ICA_REPO_PATH}/config/project.yaml
" register-tool-run-instance\:"Register an ICA workflow run instance of a tool for a given project
" register-workflow-run-instance\:"Register an ICA workflow run instance of a workflow for a given project
" schema-init\:"Register a schema in \${CWL_ICA_REPO_PATH}/config/schema.yaml
" schema-sync\:"Sync a schema in \${CWL_ICA_REPO_PATH}/config/schema.yaml
" schema-validate\:"Validate a CWL schema
" set-default-project\:"Set a project to the default project
" set-default-tenant\:"Set a tenant to the default tenant
" set-default-user\:"Set a user to the default user
" tool-init\:"Register a tool in \${CWL_ICA_REPO_PATH}/config/tool.yaml and with ICA projects
" tool-sync\:"Sync a tool md5sum in \${CWL_ICA_REPO_PATH}/config/tool.yaml
and update definition on ICA
" tool-validate\:"Validate a CWL tool ready for initialising on ICA
" typescript-expression-update\:"Update a typescript expression yarn.lock file
" typescript-expression-validate\:"Validate a typescript expression and generate a .cwljs file ready for importation
" validate-api-key-script\:"Confirm your api-key script works for a given project
" validate-config-yamls\:"Confirm all config yamls are legitimate
" version\:"Print version and exit
" workflow-init\:"Register a workflow in \${CWL_ICA_REPO_PATH}/config/workflow.yaml and with ICA projects
" workflow-sync\:"Sync a workflows md5sum in \${CWL_ICA_REPO_PATH}/config/workflow.yaml
and update definition on ICA
" workflow-validate\:"Validate a CWL workflow ready for initialising on ICA
"))'
        ;;

        args)
            case $line[1] in
            _meta)

                # ---- Command: _meta
                _arguments -s -C \
                    '1: :->cmd1' \
                    '2: :->cmd2' \
                    '*: :->args' \
                    && ret=0


                case $state in
                cmd2)
                    _alternative 'args:cmd3:((completion\:"Shell completion functions" pod\:"Pod documentation"))'
                ;;

                args)
                    case $line[2] in
                    completion)

                        # ---- Command: _meta completion
                        _arguments -s -C \
                            '1: :->cmd1' \
                            '2: :->cmd2' \
                            '3: :->cmd3' \
                            '*: :->args' \
                            && ret=0


                        case $state in
                        cmd3)
                            _alternative 'args:cmd4:((generate\:"Generate self completion"))'
                        ;;

                        args)
                            case $line[3] in
                            generate)

                                # ---- Command: _meta completion generate
                                _arguments -s -C \
                                    '1: :->cmd1' \
                                    '2: :->cmd2' \
                                    '3: :->cmd3' \
                                    '--help[Show command help]' \
                                    '-h[Show command help]' \
                                    '--name[name of the program (optional, override name in spec)]:name' \
                                    '--zsh[for zsh]' \
                                    '--bash[for bash]' \
                                    && ret=0


                            ;;
                            esac

                        ;;

                        esac
                    ;;
                    pod)

                        # ---- Command: _meta pod
                        _arguments -s -C \
                            '1: :->cmd1' \
                            '2: :->cmd2' \
                            '3: :->cmd3' \
                            '*: :->args' \
                            && ret=0


                        case $state in
                        cmd3)
                            _alternative 'args:cmd4:((generate\:"Generate self pod"))'
                        ;;

                        args)
                            case $line[3] in
                            generate)

                                # ---- Command: _meta pod generate
                                _arguments -s -C \
                                    '1: :->cmd1' \
                                    '2: :->cmd2' \
                                    '3: :->cmd3' \
                                    '--help[Show command help]' \
                                    '-h[Show command help]' \
                                    && ret=0


                            ;;
                            esac

                        ;;

                        esac
                    ;;
                    esac

                ;;

                esac
            ;;
            add-category-to-tool)

                # ---- Command: add-category-to-tool
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--tool-name[Name of the tool
]:tool-name:_cwl-ica_add-category-to-tool_option_tool_name_completion' \
                    '--category-name[The name of the category
]:category-name:_cwl-ica_add-category-to-tool_option_category_name_completion' \
                    && ret=0


            ;;
            add-category-to-workflow)

                # ---- Command: add-category-to-workflow
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--workflow-name[Name of the workflow
]:workflow-name:_cwl-ica_add-category-to-workflow_option_workflow_name_completion' \
                    '--category-name[The name of the category
]:category-name:_cwl-ica_add-category-to-workflow_option_category_name_completion' \
                    && ret=0


            ;;
            add-linked-project)

                # ---- Command: add-linked-project
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--src-project[The name of your project in project.yaml
]:src-project:_cwl-ica_add-linked-project_option_src_project_completion' \
                    '--target-project[ID of the target project to receive all ica workflows and ica workflow versions
]:target-project' \
                    && ret=0


            ;;
            add-maintainer-to-expression)

                # ---- Command: add-maintainer-to-expression
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--expression-path[Path to cwl expression
]:expression-path:_cwl-ica_add-maintainer-to-expression_option_expression_path_completion' \
                    '--username[Name of maintainer
]:username:_cwl-ica_add-maintainer-to-expression_option_username_completion' \
                    && ret=0


            ;;
            add-maintainer-to-tool)

                # ---- Command: add-maintainer-to-tool
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--tool-path[Path to cwl tool
]:tool-path:_cwl-ica_add-maintainer-to-tool_option_tool_path_completion' \
                    '--username[Name of maintainer
]:username:_cwl-ica_add-maintainer-to-tool_option_username_completion' \
                    && ret=0


            ;;
            add-maintainer-to-workflow)

                # ---- Command: add-maintainer-to-workflow
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--workflow-path[Path to cwl workflow
]:workflow-path:_cwl-ica_add-maintainer-to-workflow_option_workflow_path_completion' \
                    '--username[Name of project
]:username:_cwl-ica_add-maintainer-to-workflow_option_username_completion' \
                    && ret=0


            ;;
            add-tool-to-project)

                # ---- Command: add-tool-to-project
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--tool-path[Path to the tool
]:tool-path:_cwl-ica_add-tool-to-project_option_tool_path_completion' \
                    '--project[Name of the project
]:project:_cwl-ica_add-tool-to-project_option_project_completion' \
                    && ret=0


            ;;
            add-workflow-to-project)

                # ---- Command: add-workflow-to-project
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--workflow-path[Path to the workflow
]:workflow-path:_cwl-ica_add-workflow-to-project_option_workflow_path_completion' \
                    '--project[Name of the project to add the workflow to
]:project:_cwl-ica_add-workflow-to-project_option_project_completion' \
                    && ret=0


            ;;
            append-typescript-directory-to-cwl-commandline-tool)

                # ---- Command: append-typescript-directory-to-cwl-commandline-tool
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--tool-path[The path to the cwl commandline tool
]:tool-path:_cwl-ica_append-typescript-directory-to-cwl-commandline-tool_option_tool_path_completion' \
                    '--xtrace[Set xtrace on the initialise_typescript_expression_directory shell script
]:xtrace' \
                    && ret=0


            ;;
            append-typescript-directory-to-cwl-expression-tool)

                # ---- Command: append-typescript-directory-to-cwl-expression-tool
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--expression-path[The path to the cwl expression tool
]:expression-path:_cwl-ica_append-typescript-directory-to-cwl-expression-tool_option_expression_path_completion' \
                    '--xtrace[Set xtrace on the initialise_typescript_expression_directory script
]:xtrace' \
                    && ret=0


            ;;
            append-typescript-directory-to-cwl-workflow)

                # ---- Command: append-typescript-directory-to-cwl-workflow
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--workflow-path[The path to the cwl workflow
]:workflow-path:_cwl-ica_append-typescript-directory-to-cwl-workflow_option_workflow_path_completion' \
                    '--xtrace[Set xtrace on the initialise_typescript_expression_directory shell script
]:xtrace' \
                    && ret=0


            ;;
            category-init)

                # ---- Command: category-init
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--category-name[Name of category
]:category-name' \
                    '--category-description[Category description
]:category-description' \
                    && ret=0


            ;;
            configure-repo)

                # ---- Command: configure-repo
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--repo-path[path to local cwl-ica repository
]:repo-path:_path_files -/' \
                    && ret=0


            ;;
            configure-tenant)

                # ---- Command: configure-tenant
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--tenant-id[The id of the tenant
]:tenant-id' \
                    '--tenant-name[The name of the tenant
]:tenant-name' \
                    '--set-as-default[Set as default tenant
]:set-as-default' \
                    && ret=0


            ;;
            configure-user)

                # ---- Command: configure-user
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--username[The name of the user
]:username' \
                    '--email[The users email address
]:email' \
                    '--identifier[The orcid ID of the user
]:identifier' \
                    '--set-as-default[Set as default user
]:set-as-default' \
                    && ret=0


            ;;
            copy-tool-submission-template)

                # ---- Command: copy-tool-submission-template
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--ica-workflow-run-instance-id[A ica workflow run instance id
]:ica-workflow-run-instance-id:_cwl-ica_copy-tool-submission-template_option_ica_workflow_run_instance_id_completion' \
                    '--prefix[The prefix to the outputs files and name attribute in the json file
]:prefix' \
                    '--curl[Use curl binary over ica binary to launch workflow
]:curl' \
                    && ret=0


            ;;
            copy-workflow-submission-template)

                # ---- Command: copy-workflow-submission-template
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--ica-workflow-run-instance-id[A ica workflow run instance id
]:ica-workflow-run-instance-id:_cwl-ica_copy-workflow-submission-template_option_ica_workflow_run_instance_id_completion' \
                    '--prefix[The prefix to the outputs files and name attribute in the json file
]:prefix' \
                    '--curl[Use curl binary over ica binary to launch workflow
]:curl' \
                    && ret=0


            ;;
            create-expression-from-template)

                # ---- Command: create-expression-from-template
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--expression-name[The name of the expression
]:expression-name' \
                    '--expression-version[Version of the expression
]:expression-version' \
                    '--username[CWL Creator
]:username:_cwl-ica_create-expression-from-template_option_username_completion' \
                    && ret=0


            ;;
            create-schema-from-template)

                # ---- Command: create-schema-from-template
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--schema-name[The name of the schema
]:schema-name' \
                    '--schema-version[Version of the schema
]:schema-version' \
                    && ret=0


            ;;
            create-tool-from-template)

                # ---- Command: create-tool-from-template
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--tool-name[The name of the tool
]:tool-name' \
                    '--tool-version[Version of the tool
]:tool-version' \
                    '--username[CWL Creator
]:username:_cwl-ica_create-tool-from-template_option_username_completion' \
                    && ret=0


            ;;
            create-tool-submission-template)

                # ---- Command: create-tool-submission-template
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--tool-path[Path to CWL tool
]:tool-path:_cwl-ica_create-tool-submission-template_option_tool_path_completion' \
                    '--prefix[Output prefix name
]:prefix' \
                    '--project[Project that tool belongs to
]:project:_cwl-ica_create-tool-submission-template_option_project_completion' \
                    '--launch-project[Name of the launch project
]:launch-project' \
                    '--ica-workflow-run-instance-id[The workflow run instance id, starts with wfr.
]:ica-workflow-run-instance-id' \
                    '--access-token[The ica access token, ideally use env var ICA_ACCESS_TOKEN instead
]:access-token' \
                    '--curl[Use curl binary over ica binary to launch tool
]:curl' \
                    '--ignore-workflow-id-mismatch[Ignore workflow id mismatch, useful for when creating a template for a different context
]:ignore-workflow-id-mismatch' \
                    '--gds-prefix[Prefix for engine parameters workDirectory, outputDirectory
]:gds-prefix:_cwl-ica_create-tool-submission-template_option_gds_prefix_completion' \
                    '--gds-work-prefix[Prefix for engine parameters workDirectory
]:gds-work-prefix:_cwl-ica_create-tool-submission-template_option_gds_work_prefix_completion' \
                    '--gds-output-prefix[Prefix for engine parameters outputDirectory
]:gds-output-prefix:_cwl-ica_create-tool-submission-template_option_gds_output_prefix_completion' \
                    '--gds-work-directory[Set engine parameters workDirectory
]:gds-work-directory:_cwl-ica_create-tool-submission-template_option_gds_work_directory_completion' \
                    '--gds-output-directory[Set engine parameters outputDirectory
]:gds-output-directory:_cwl-ica_create-tool-submission-template_option_gds_output_directory_completion' \
                    && ret=0


            ;;
            create-typescript-expression-from-template)

                # ---- Command: create-typescript-expression-from-template
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--typescript-expression-name[The name of the typescript-expression
]:typescript-expression-name' \
                    '--typescript-expression-version[Version of the typescript expression
]:typescript-expression-version' \
                    '--username[CWL Creator
]:username:_cwl-ica_create-typescript-expression-from-template_option_username_completion' \
                    && ret=0


            ;;
            create-typescript-interface-from-cwl-schema)

                # ---- Command: create-typescript-interface-from-cwl-schema
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--schema-path[The name of the tool
]:schema-path:_cwl-ica_create-typescript-interface-from-cwl-schema_option_schema_path_completion' \
                    && ret=0


            ;;
            create-workflow-from-template)

                # ---- Command: create-workflow-from-template
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--workflow-name[The name of the workflow
]:workflow-name' \
                    '--workflow-version[Version of the workflow
]:workflow-version' \
                    '--username[CWL Creator
]:username:_cwl-ica_create-workflow-from-template_option_username_completion' \
                    && ret=0


            ;;
            create-workflow-submission-template)

                # ---- Command: create-workflow-submission-template
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--workflow-path[Path to CWL workflow
]:workflow-path:_cwl-ica_create-workflow-submission-template_option_workflow_path_completion' \
                    '--prefix[Output prefix name
]:prefix' \
                    '--project[Project that workflow belongs to
]:project:_cwl-ica_create-workflow-submission-template_option_project_completion' \
                    '--launch-project[Name of the launch project
]:launch-project' \
                    '--ica-workflow-run-instance-id[The workflow run instance id, starts with wfr.
]:ica-workflow-run-instance-id' \
                    '--access-token[The ica access token, ideally use env var ICA_ACCESS_TOKEN instead
]:access-token' \
                    '--curl[Use curl binary over ica binary to launch workflow
]:curl' \
                    '--ignore-workflow-id-mismatch[Ignore workflow id mismatch, useful for when creating a template for a different context
]:ignore-workflow-id-mismatch' \
                    '--gds-prefix[Prefix for engine parameters workDirectory, outputDirectory
]:gds-prefix:_cwl-ica_create-workflow-submission-template_option_gds_prefix_completion' \
                    '--gds-work-prefix[Prefix for engine parameters workDirectory
]:gds-work-prefix:_cwl-ica_create-workflow-submission-template_option_gds_work_prefix_completion' \
                    '--gds-output-prefix[Prefix for engine parameters outputDirectory
]:gds-output-prefix:_cwl-ica_create-workflow-submission-template_option_gds_output_prefix_completion' \
                    '--gds-work-directory[Set engine parameters workDirectory
]:gds-work-directory:_cwl-ica_create-workflow-submission-template_option_gds_work_directory_completion' \
                    '--gds-output-directory[Set engine parameters outputDirectory
]:gds-output-directory:_cwl-ica_create-workflow-submission-template_option_gds_output_directory_completion' \
                    && ret=0


            ;;
            expression-init)

                # ---- Command: expression-init
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--expression-path[Path to the expression
]:expression-path:_cwl-ica_expression-init_option_expression_path_completion' \
                    && ret=0


            ;;
            expression-sync)

                # ---- Command: expression-sync
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--expression-path[Path to the expression
]:expression-path:_cwl-ica_expression-sync_option_expression_path_completion' \
                    && ret=0


            ;;
            expression-validate)

                # ---- Command: expression-validate
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--expression-path[Path to the expression
]:expression-path:_cwl-ica_expression-validate_option_expression_path_completion' \
                    && ret=0


            ;;
            get-workflow-step-ids)

                # ---- Command: get-workflow-step-ids
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--workflow-path[A cwl workflow file
]:workflow-path:_cwl-ica_get-workflow-step-ids_option_workflow_path_completion' \
                    && ret=0


            ;;
            help)

                # ---- Command: help
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    && ret=0


            ;;
            icav2-deploy-pipeline)

                # ---- Command: icav2-deploy-pipeline
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--zipped-workflow-path[Required, path to zipped up workflow
]:zipped-workflow-path' \
                    '--project-id[Optional, provide the project id (takes precedence over project-name)
]:project-id:_cwl-ica_icav2-deploy-pipeline_option_project_id_completion' \
                    '--project-name[Optional, provide the project name
]:project-name:_cwl-ica_icav2-deploy-pipeline_option_project_name_completion' \
                    '--analysis-storage-id[Optional, takes precedence over analysis-storage-size
]:analysis-storage-id:_cwl-ica_icav2-deploy-pipeline_option_analysis_storage_id_completion' \
                    '--analysis-storage-size[Optional, default is set to Small
]:analysis-storage-size:_cwl-ica_icav2-deploy-pipeline_option_analysis_storage_size_completion' \
                    && ret=0


            ;;
            icav2-get-analysis-step-logs)

                # ---- Command: icav2-get-analysis-step-logs
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--project-id[Optional, provide the project id, takes precedence over project-name
]:project-id:_cwl-ica_icav2-get-analysis-step-logs_option_project_id_completion' \
                    '--project-name[Optional, provide the project name
]:project-name:_cwl-ica_icav2-get-analysis-step-logs_option_project_name_completion' \
                    '--analysis-id[Required, the analysis id you wish to list logs of
]:analysis-id' \
                    '--step-name[The name of the step
]:step-name' \
                    '--stdout[Get the stdout of a step
]:stdout' \
                    '--stderr[Get the stderr of a step
]:stderr' \
                    '--output-path[Write output to file
]:output-path' \
                    && ret=0


            ;;
            icav2-launch-pipeline-analysis)

                # ---- Command: icav2-launch-pipeline-analysis
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--launch-json[Required, launch json similar to v1
]:launch-json:_cwl-ica_icav2-launch-pipeline-analysis_option_launch_json_completion' \
                    '--pipeline-id[Optional, id of the pipeline you wish to launch
]:pipeline-id:_cwl-ica_icav2-launch-pipeline-analysis_option_pipeline_id_completion' \
                    '--pipeline-code[Optional, code of the pipeline you wish to launch
]:pipeline-code:_cwl-ica_icav2-launch-pipeline-analysis_option_pipeline_code_completion' \
                    '--project-id[Optional, provide the project id, takes precedence over project-name
]:project-id:_cwl-ica_icav2-launch-pipeline-analysis_option_project_id_completion' \
                    '--project-name[Optional, provide the project name
]:project-name:_cwl-ica_icav2-launch-pipeline-analysis_option_project_name_completion' \
                    '--output-parent-folder-id[Optional, the id of the parent folder to write outputs to
]:output-parent-folder-id' \
                    '--output-parent-folder-path[Optional, the path to the parent folder to write outputs to (will be created if it doesn'"'"'t exist)
]:output-parent-folder-path:_cwl-ica_icav2-launch-pipeline-analysis_option_output_parent_folder_path_completion' \
                    '--analysis-storage-id[Optional, takes precedence over analysis-storage-size
]:analysis-storage-id:_cwl-ica_icav2-launch-pipeline-analysis_option_analysis_storage_id_completion' \
                    '--analysis-storage-size[Optional, default is set to Small
]:analysis-storage-size:_cwl-ica_icav2-launch-pipeline-analysis_option_analysis_storage_size_completion' \
                    '--activation-id[Optional, the activation id used by the pipeline analysis
]:activation-id' \
                    '--create-cwl-analysis-json-output-path[Path to output a json file that contains the body for a create cwl analysis
]:create-cwl-analysis-json-output-path' \
                    && ret=0


            ;;
            icav2-list-analysis-steps)

                # ---- Command: icav2-list-analysis-steps
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--project-id[Optional, provide the project id, takes precedence over project-name
]:project-id:_cwl-ica_icav2-list-analysis-steps_option_project_id_completion' \
                    '--project-name[Optional, provide the project name
]:project-name:_cwl-ica_icav2-list-analysis-steps_option_project_name_completion' \
                    '--analysis-id[Required, the analysis id you wish to list logs of
]:analysis-id' \
                    '--show-technical-steps[Also list technical steps
]:show-technical-steps' \
                    && ret=0


            ;;
            icav2-zip-workflow)

                # ---- Command: icav2-zip-workflow
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--workflow-path[The path to the cwl workflow
]:workflow-path:_cwl-ica_icav2-zip-workflow_option_workflow_path_completion' \
                    '--output-path[Optional, set the output path, otherwise just the working directory]:output-path' \
                    '--force[Optional, override existing zip file if one already exists]:force' \
                    && ret=0


            ;;
            list-categories)

                # ---- Command: list-categories
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    && ret=0


            ;;
            list-projects)

                # ---- Command: list-projects
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--tenant-name[Name of tenant
]:tenant-name:_cwl-ica_list-projects_option_tenant_name_completion' \
                    && ret=0


            ;;
            list-tenants)

                # ---- Command: list-tenants
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    && ret=0


            ;;
            list-tool-runs)

                # ---- Command: list-tool-runs
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--tool-path[A cwl tool file
]:tool-path:_cwl-ica_list-tool-runs_option_tool_path_completion' \
                    '--project[A project name
]:project:_cwl-ica_list-tool-runs_option_project_completion' \
                    && ret=0


            ;;
            list-users)

                # ---- Command: list-users
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    && ret=0


            ;;
            list-workflow-runs)

                # ---- Command: list-workflow-runs
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--workflow-path[A cwl workflow file
]:workflow-path:_cwl-ica_list-workflow-runs_option_workflow_path_completion' \
                    '--project[A project name
]:project:_cwl-ica_list-workflow-runs_option_project_completion' \
                    && ret=0


            ;;
            project-init)

                # ---- Command: project-init
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--project-id[The ICA project id
]:project-id' \
                    '--project-name[The name of the project
]:project-name' \
                    '--project-api-key-name[Required, this is NOT an api-key, but merely an api-key with a workgroup
context that can create an access-token for this project
]:project-api-key-name' \
                    '--project-description[Required, a short summary of the project
]:project-description' \
                    '--project-abbr[Required, a quick abbreviation of the project name - used to append
to workflow names
]:project-abbr' \
                    '--production[Optional, boolean, if set, the project is a production project
]:production' \
                    '--tenant-name[Optional, the tenant name
]:tenant-name:_cwl-ica_project-init_option_tenant_name_completion' \
                    '--set-as-default[Optional, set as the default project
]:set-as-default' \
                    && ret=0


            ;;
            register-tool-run-instance)

                # ---- Command: register-tool-run-instance
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--ica-workflow-run-instance-id[A workflow run instance id (starts with wfr.)
]:ica-workflow-run-instance-id' \
                    '--project-name[Name of project
]:project-name:_cwl-ica_register-tool-run-instance_option_project_name_completion' \
                    '--access-token[ica access token, if run instance was executed in a linked project context
]:access-token' \
                    && ret=0


            ;;
            register-workflow-run-instance)

                # ---- Command: register-workflow-run-instance
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--ica-workflow-run-instance-id[A workflow run instance id (starts with wfr.)
]:ica-workflow-run-instance-id' \
                    '--project-name[Name of project
]:project-name:_cwl-ica_register-workflow-run-instance_option_project_name_completion' \
                    '--access-token[ica access token, if run instance was executed in a linked project context
]:access-token' \
                    && ret=0


            ;;
            schema-init)

                # ---- Command: schema-init
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--schema-path[Path to the schema
]:schema-path:_cwl-ica_schema-init_option_schema_path_completion' \
                    && ret=0


            ;;
            schema-sync)

                # ---- Command: schema-sync
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--schema-path[Path to the schema
]:schema-path:_cwl-ica_schema-sync_option_schema_path_completion' \
                    '--force[Overwrite on ICA even if mod time in yaml is behind
]:force' \
                    && ret=0


            ;;
            schema-validate)

                # ---- Command: schema-validate
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--schema-path[Path to the schema
]:schema-path:_cwl-ica_schema-validate_option_schema_path_completion' \
                    && ret=0


            ;;
            set-default-project)

                # ---- Command: set-default-project
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--project-name[Name of project
]:project-name:_cwl-ica_set-default-project_option_project_name_completion' \
                    && ret=0


            ;;
            set-default-tenant)

                # ---- Command: set-default-tenant
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--tenant-name[Name of tenant
]:tenant-name:_cwl-ica_set-default-tenant_option_tenant_name_completion' \
                    && ret=0


            ;;
            set-default-user)

                # ---- Command: set-default-user
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--username[Name of user
]:username:_cwl-ica_set-default-user_option_username_completion' \
                    && ret=0


            ;;
            tool-init)

                # ---- Command: tool-init
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--tool-path[Path to the tool
]:tool-path:_cwl-ica_tool-init_option_tool_path_completion' \
                    '--projects[List of projects to add the tool to
]:projects:_cwl-ica_tool-init_option_projects_completion' \
                    '--tenants[List of tenants to filter by when project set to '"'"'all'"'"'
]:tenants:_cwl-ica_tool-init_option_tenants_completion' \
                    '--categories[List of categories to add to tool
]:categories:_cwl-ica_tool-init_option_categories_completion' \
                    && ret=0


            ;;
            tool-sync)

                # ---- Command: tool-sync
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--tool-path[Path to the tool
]:tool-path:_cwl-ica_tool-sync_option_tool_path_completion' \
                    '--projects[List of projects to sync the tool to
]:projects:_cwl-ica_tool-sync_option_projects_completion' \
                    '--tenants[List of tenants to filter by when project set to '"'"'all'"'"'
]:tenants:_cwl-ica_tool-sync_option_tenants_completion' \
                    && ret=0


            ;;
            tool-validate)

                # ---- Command: tool-validate
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--tool-path[Path to the tool
]:tool-path:_cwl-ica_tool-validate_option_tool_path_completion' \
                    && ret=0


            ;;
            typescript-expression-update)

                # ---- Command: typescript-expression-update
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--typescript-expression-dir[The name of the workflow
]:typescript-expression-dir:_cwl-ica_typescript-expression-update_option_typescript_expression_dir_completion' \
                    '--xtrace[Set xtrace on the update_yarn_dependencies shell script
]:xtrace' \
                    && ret=0


            ;;
            typescript-expression-validate)

                # ---- Command: typescript-expression-validate
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--typescript-expression-dir[The name of the workflow
]:typescript-expression-dir:_cwl-ica_typescript-expression-validate_option_typescript_expression_dir_completion' \
                    '--xtrace[Set xtrace on the validate_typescript_expressions_directory shell script
]:xtrace' \
                    && ret=0


            ;;
            validate-api-key-script)

                # ---- Command: validate-api-key-script
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--project-name[Name of your project
]:project-name:_cwl-ica_validate-api-key-script_option_project_name_completion' \
                    && ret=0


            ;;
            validate-config-yamls)

                # ---- Command: validate-config-yamls
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    && ret=0


            ;;
            version)

                # ---- Command: version
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    && ret=0


            ;;
            workflow-init)

                # ---- Command: workflow-init
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--workflow-path[Path to the workflow
]:workflow-path:_cwl-ica_workflow-init_option_workflow_path_completion' \
                    '--projects[List of projects to add the tool to
]:projects:_cwl-ica_workflow-init_option_projects_completion' \
                    '--tenants[List of tenants to filter by when project set to '"'"'all'"'"'
]:tenants:_cwl-ica_workflow-init_option_tenants_completion' \
                    '--categories[List of categories to add to tool
]:categories:_cwl-ica_workflow-init_option_categories_completion' \
                    && ret=0


            ;;
            workflow-sync)

                # ---- Command: workflow-sync
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--workflow-path[Path to the workflow
]:workflow-path:_cwl-ica_workflow-sync_option_workflow_path_completion' \
                    '--projects[List of projects to sync the workflow to
]:projects:_cwl-ica_workflow-sync_option_projects_completion' \
                    '--tenants[List of tenants to filter by when project set to '"'"'all'"'"'
]:tenants:_cwl-ica_workflow-sync_option_tenants_completion' \
                    '--force[Overwrite on ICA even if mod time in yaml is behind
]:force' \
                    && ret=0


            ;;
            workflow-validate)

                # ---- Command: workflow-validate
                _arguments -s -C \
                    '1: :->cmd1' \
                    '--help[Show command help]' \
                    '-h[Show command help]' \
                    '--workflow-path[Path to the workflow
]:workflow-path:_cwl-ica_workflow-validate_option_workflow_path_completion' \
                    && ret=0


            ;;
            esac

        ;;

        esac

}

_cwl-ica_add-category-to-tool_option_tool_name_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the category names in the categories.yaml file
"""
# CWL ICA imports
from cwl_ica.utils.repo import get_tool_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each tool name
for tool in read_yaml(get_tool_yaml_path())["tools"]:
    print(tool["name"])
EOF

 ) )
    compadd -X "tool_name:" $__dynamic_completion
}
_cwl-ica_add-category-to-tool_option_category_name_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the category names in the categories.yaml file
"""
from cwl_ica.utils.repo import get_category_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each project name
for category in read_yaml(get_category_yaml_path())["categories"]:
    print(category["name"])
EOF

 ) )
    compadd -X "category_name:" $__dynamic_completion
}
_cwl-ica_add-category-to-workflow_option_workflow_name_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the category names in the categories.yaml file
"""
# CWL ICA imports
from cwl_ica.utils.repo import get_workflow_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each tool name
for workflow in read_yaml(get_workflow_yaml_path())["workflows"]:
    print(workflow["name"])
EOF

 ) )
    compadd -X "workflow_name:" $__dynamic_completion
}
_cwl-ica_add-category-to-workflow_option_category_name_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the category names in the categories.yaml file
"""
from cwl_ica.utils.repo import get_category_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each project name
for category in read_yaml(get_category_yaml_path())["categories"]:
    print(category["name"])
EOF

 ) )
    compadd -X "category_name:" $__dynamic_completion
}
_cwl-ica_add-linked-project_option_src_project_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the project names in the project.yaml file
"""
from cwl_ica.utils.repo import get_project_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each project name
for project in read_yaml(get_project_yaml_path())["projects"]:
    print(project["project_name"])
EOF

 ) )
    compadd -X "src_project:" $__dynamic_completion
}
_cwl-ica_add-maintainer-to-expression_option_expression_path_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python3

"""
List the unregistered expression paths
"""

# Externals
from pathlib import Path
from os import getcwd
from os.path import relpath

# CWL ICA
from cwl_ica.utils.repo import get_expression_yaml_path
from cwl_ica.utils.repo import get_expressions_dir
from cwl_ica.utils.miscell import read_yaml

# Get the current word value
if not "${CURRENT_WORD}" == "":
    current_word_value = "${CURRENT_WORD}"
else:
    current_word_value = None

# Resolve the current path
# If getcwd() is "/c/Users/awluc"
# 1. Non relative paths: current_word_value = "/etc" -> current_path_resolved = "/etc"
# 2. Relative parent path: current_word_value = "../../Program Files" -> current_path_resolved = "/c/Program Files"
# 3. Subfolder: current_word_value = "OneDrive" -> current_path_resolved = "/c/Users/awluc/OneDrive"
# 4. Subfolder of expressions dir = "OneDrive/GitHub/UMCCR/expressions/contig/" -> current path resolved
if current_word_value is not None:
    if current_word_value.endswith("/"):
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value)).resolve()
    else:
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value).parent).resolve()

else:
    current_word_value = ""
    current_path_resolved = Path(getcwd()).absolute()

# Is the current_path_resolved a subpath of the expressions directory?
try:
    _ = current_path_resolved.relative_to(get_expressions_dir())
    in_expressions_dir = True
except ValueError:
    in_expressions_dir = False

if not current_word_value == "" and in_expressions_dir:
    expression_paths = [
        s_file.relative_to(get_expressions_dir())
        for s_file in current_path_resolved.glob("**/*.cwl")
    ]
else:
    expression_paths = [
        s_file.relative_to(get_expressions_dir())
        for s_file in get_expressions_dir().glob("**/*.cwl")
    ]

if in_expressions_dir:
    current_path_resolved_relative_to_expressions_dir = current_path_resolved.relative_to(get_expressions_dir())
    if current_path_resolved_relative_to_expressions_dir == Path("."):
        for s_path in expression_paths:
            if current_word_value.endswith("/"):
                print(Path(current_word_value) / s_path)
            else:
                print(Path(current_word_value).parent / s_path)
    else:
        for s_path in expression_paths:
            if str(s_path).startswith(str(current_path_resolved_relative_to_expressions_dir)):
                if current_word_value.endswith("/"):
                    print(Path(current_word_value) / s_path.relative_to(
                        current_path_resolved_relative_to_expressions_dir))
                else:
                    print(Path(current_word_value).parent / s_path.relative_to(
                        current_path_resolved_relative_to_expressions_dir))

else:
    # Now get the expressions yaml path relative to the current path
    try:
        expressions_dir = get_expressions_dir().relative_to(current_path_resolved)
    except ValueError:
        # We could be in a different mount point OR just in a subdirectory
        if str(get_expressions_dir().absolute()) in str(relpath(get_expressions_dir(), current_path_resolved)):
            # Separate mount point
            expressions_dir = get_expressions_dir().absolute()
        else:
            expressions_dir = Path(relpath(get_expressions_dir(), current_path_resolved))

    # Now iterate through paths
    for s_path in expression_paths:
        if current_word_value.endswith("/"):
            print(Path(current_word_value) / expressions_dir.joinpath(s_path))
        else:
            print(Path(current_word_value).parent / expressions_dir.joinpath(s_path))
EOF

 ) )
    compadd -X "expression_path:" $__dynamic_completion
}
_cwl-ica_add-maintainer-to-expression_option_username_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the category names in the categories.yaml file
"""
# CWL ICA imports
from cwl_ica.utils.repo import get_user_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each project name
for user in read_yaml(get_user_yaml_path())["users"]:
    print(user["username"])
EOF

 ) )
    compadd -X "username:" $__dynamic_completion
}
_cwl-ica_add-maintainer-to-tool_option_tool_path_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python3

"""
List the unregistered tool paths
"""

# Externals
from pathlib import Path
from os import getcwd
from os.path import relpath

# CWL ICA
from cwl_ica.utils.repo import get_tools_dir

# Get the current word value
if not "${CURRENT_WORD}" == "":
    current_word_value = "${CURRENT_WORD}"
else:
    current_word_value = None

# Resolve the current path
# If getcwd() is "/c/Users/awluc"
# 1. Non relative paths: current_word_value = "/etc" -> current_path_resolved = "/etc"
# 2. Relative parent path: current_word_value = "../../Program Files" -> current_path_resolved = "/c/Program Files"
# 3. Subfolder: current_word_value = "OneDrive" -> current_path_resolved = "/c/Users/awluc/OneDrive"
# 4. Subfolder of tools dir = "OneDrive/GitHub/UMCCR/tools/contig/" -> current path resolved
if current_word_value is not None:
    if current_word_value.endswith("/"):
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value)).resolve()
    else:
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value).parent).resolve()
else:
    current_word_value = ""
    current_path_resolved = Path(getcwd()).absolute()


# Is the current_path_resolved a subpath of the tools directory?
try:
    _ = current_path_resolved.relative_to(get_tools_dir())
    in_tools_dir = True
except ValueError:
    in_tools_dir = False

if not current_word_value == "" and in_tools_dir:
    tool_paths = [
        s_file.relative_to(get_tools_dir())
        for s_file in current_path_resolved.glob("**/*.cwl")
    ]
else:
    tool_paths = [
        s_file.relative_to(get_tools_dir())
        for s_file in get_tools_dir().glob("**/*.cwl")
    ]

if in_tools_dir:
    current_path_resolved_relative_to_tools_dir = current_path_resolved.relative_to(get_tools_dir())
    if current_path_resolved_relative_to_tools_dir == Path("."):
        for s_path in tool_paths:
            if current_word_value.endswith("/"):
                print(Path(current_word_value) / s_path)
            else:
                print(Path(current_word_value).parent / s_path)
    else:
        for s_path in tool_paths:
            if str(s_path).startswith(str(current_path_resolved_relative_to_tools_dir)):
                if current_word_value.endswith("/"):
                    print(Path(current_word_value) / s_path.relative_to(current_path_resolved_relative_to_tools_dir))
                else:
                    print(Path(current_word_value).parent / s_path.relative_to(
                        current_path_resolved_relative_to_tools_dir))

else:
    # Now get the tools yaml path relative to the current path
    try:
        tools_dir = get_tools_dir().relative_to(current_path_resolved)
    except ValueError:
        # We could be in a different mount point OR just in a subdirectory
        if str(get_tools_dir().absolute()) in str(relpath(get_tools_dir(), current_path_resolved)):
            # Separate mount point
            tools_dir = get_tools_dir().absolute()
        else:
            tools_dir = Path(relpath(get_tools_dir(), current_path_resolved))

    # Now iterate through paths
    for s_path in tool_paths:
        if current_word_value.endswith("/"):
            print(Path(current_word_value) / tools_dir.joinpath(s_path))
        else:
            print(Path(current_word_value).parent / tools_dir.joinpath(s_path))
EOF

 ) )
    compadd -X "tool_path:" $__dynamic_completion
}
_cwl-ica_add-maintainer-to-tool_option_username_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the category names in the categories.yaml file
"""
# CWL ICA imports
from cwl_ica.utils.repo import get_user_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each project name
for user in read_yaml(get_user_yaml_path())["users"]:
    print(user["username"])
EOF

 ) )
    compadd -X "username:" $__dynamic_completion
}
_cwl-ica_add-maintainer-to-workflow_option_workflow_path_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python3

"""
List the unregistered workflow paths
"""

# Externals
from pathlib import Path
from os import getcwd
from os.path import relpath

# CWL ICA
from cwl_ica.utils.repo import get_workflows_dir

# Get the current word value
if not "${CURRENT_WORD}" == "":
    current_word_value = "${CURRENT_WORD}"
else:
    current_word_value = None

# Resolve the current path
# If getcwd() is "/c/Users/awluc"
# 1. Non relative paths: current_word_value = "/etc" -> current_path_resolved = "/etc"
# 2. Relative parent path: current_word_value = "../../Program Files" -> current_path_resolved = "/c/Program Files"
# 3. Subfolder: current_word_value = "OneDrive" -> current_path_resolved = "/c/Users/awluc/OneDrive"
# 4. Subfolder of workflows dir = "OneDrive/GitHub/UMCCR/workflows/contig/" -> current path resolved
if current_word_value is not None:
    if current_word_value.endswith("/"):
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value)).resolve()
    else:
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value).parent).resolve()
else:
    current_word_value = ""
    current_path_resolved = Path(getcwd()).absolute()


# Is the current_path_resolved a subpath of the workflows directory?
try:
    _ = current_path_resolved.relative_to(get_workflows_dir())
    in_workflows_dir = True
except ValueError:
    in_workflows_dir = False

if not current_word_value == "" and in_workflows_dir:
    workflow_paths = [
        s_file.relative_to(get_workflows_dir())
        for s_file in current_path_resolved.glob("**/*.cwl")
    ]
else:
    workflow_paths = [
        s_file.relative_to(get_workflows_dir())
        for s_file in get_workflows_dir().glob("**/*.cwl")
    ]

if in_workflows_dir:
    current_path_resolved_relative_to_workflows_dir = current_path_resolved.relative_to(get_workflows_dir())
    if current_path_resolved_relative_to_workflows_dir == Path("."):
        for s_path in workflow_paths:
            if current_word_value.endswith("/"):
                print(Path(current_word_value) / s_path)
            else:
                print(Path(current_word_value).parent / s_path)
    else:
        for s_path in workflow_paths:
            if str(s_path).startswith(str(current_path_resolved_relative_to_workflows_dir)):
                if current_word_value.endswith("/"):
                    print(
                        Path(current_word_value) / s_path.relative_to(current_path_resolved_relative_to_workflows_dir))
                else:
                    print(Path(current_word_value).parent / s_path.relative_to(
                        current_path_resolved_relative_to_workflows_dir))

else:
    # Now get the workflows yaml path relative to the current path
    try:
        workflows_dir = get_workflows_dir().relative_to(current_path_resolved)
    except ValueError:
        # We could be in a different mount point OR just in a subdirectory
        if str(get_workflows_dir().absolute()) in str(relpath(get_workflows_dir(), current_path_resolved)):
            # Separate mount point
            workflows_dir = get_workflows_dir().absolute()
        else:
            workflows_dir = Path(relpath(get_workflows_dir(), current_path_resolved))

    # Now iterate through paths
    for s_path in workflow_paths:
        if current_word_value.endswith("/"):
            print(Path(current_word_value) / workflows_dir.joinpath(s_path))
        else:
            print(Path(current_word_value).parent / workflows_dir.joinpath(s_path))
EOF

 ) )
    compadd -X "workflow_path:" $__dynamic_completion
}
_cwl-ica_add-maintainer-to-workflow_option_username_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the category names in the categories.yaml file
"""
# CWL ICA imports
from cwl_ica.utils.repo import get_user_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each project name
for user in read_yaml(get_user_yaml_path())["users"]:
    print(user["username"])
EOF

 ) )
    compadd -X "username:" $__dynamic_completion
}
_cwl-ica_add-tool-to-project_option_tool_path_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python3

"""
List the registered tool paths
"""

# External imports
from pathlib import Path
from os import getcwd
from os.path import relpath

# CWL ICA
from cwl_ica.utils.repo import get_tool_yaml_path
from cwl_ica.utils.repo import get_tools_dir
from cwl_ica.utils.miscell import read_yaml

tool_paths = [
    Path(tool["path"]) / Path(version["path"])
    for tool in read_yaml(get_tool_yaml_path())["tools"]
    for version in tool["versions"]
]

# Get the current word value
if not "${CURRENT_WORD}" == "":
    current_word_value = "${CURRENT_WORD}"
else:
    current_word_value = None

# Resolve the current path
# If getcwd() is "/c/Users/awluc"
# 1. Non relative paths: current_word_value = "/etc" -> current_path_resolved = "/etc"
# 2. Relative parent path: current_word_value = "../../Program Files" -> current_path_resolved = "/c/Program Files"
# 3. Subfolder: current_word_value = "OneDrive" -> current_path_resolved = "/c/Users/awluc/OneDrive"
# 4. Subfolder of tools dir = "OneDrive/GitHub/UMCCR/tools/contig/" -> current path resolved
if current_word_value is not None:
    if current_word_value.endswith("/"):
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value)).resolve()
    else:
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value).parent).resolve()

else:
    current_word_value = ""
    current_path_resolved = Path(getcwd()).absolute()

# Is the current_path_resolved a subpath of the tools directory?
try:
    _ = current_path_resolved.relative_to(get_tools_dir())
    in_tools_dir = True
except ValueError:
    in_tools_dir = False

if in_tools_dir:
    current_path_resolved_relative_to_tools_dir = current_path_resolved.relative_to(get_tools_dir())
    if current_path_resolved_relative_to_tools_dir == Path("."):
        for s_path in tool_paths:
            if current_word_value.endswith("/"):
                print(Path(current_word_value) / s_path)
            else:
                print(Path(current_word_value).parent / s_path)
    else:
        for s_path in tool_paths:
            if str(s_path).startswith(str(current_path_resolved_relative_to_tools_dir)):
                if current_word_value.endswith("/"):
                    print(Path(current_word_value) / s_path.relative_to(current_path_resolved_relative_to_tools_dir))
                else:
                    print(Path(current_word_value).parent / s_path.relative_to(
                        current_path_resolved_relative_to_tools_dir))

else:
    # Now get the tools yaml path relative to the current path
    try:
        tools_dir = get_tools_dir().relative_to(current_path_resolved)
    except ValueError:
        # We could be in a different mount point OR just in a subdirectory
        if str(get_tools_dir().absolute()) in str(relpath(get_tools_dir(), current_path_resolved)):
            # Separate mount point
            tools_dir = get_tools_dir().absolute()
        else:
            tools_dir = Path(relpath(get_tools_dir(), current_path_resolved))

    # Now iterate through paths
    for s_path in tool_paths:
        if current_word_value.endswith("/"):
            print(Path(current_word_value) / tools_dir.joinpath(s_path))
        else:
            print(Path(current_word_value).parent / tools_dir.joinpath(s_path))
EOF

 ) )
    compadd -X "tool_path:" $__dynamic_completion
}
_cwl-ica_add-tool-to-project_option_project_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the project names in the project.yaml file
"""
from cwl_ica.utils.repo import get_project_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each project name
for project in read_yaml(get_project_yaml_path())["projects"]:
    print(project["project_name"])
EOF

 ) )
    compadd -X "project:" $__dynamic_completion
}
_cwl-ica_add-workflow-to-project_option_workflow_path_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python3

"""
List the registered workflow paths
"""

# External imports
from pathlib import Path
from os import getcwd
from os.path import relpath

# CWL ICA
from cwl_ica.utils.repo import get_workflow_yaml_path
from cwl_ica.utils.repo import get_workflows_dir
from cwl_ica.utils.miscell import read_yaml

workflow_paths = [
    Path(workflow["path"]) / Path(version["path"])
    for workflow in read_yaml(get_workflow_yaml_path())["workflows"]
    for version in workflow["versions"]
]

# Get the current word value
if not "${CURRENT_WORD}" == "":
    current_word_value = "${CURRENT_WORD}"
else:
    current_word_value = None

# Resolve the current path
# If getcwd() is "/c/Users/awluc"
# 1. Non relative paths: current_word_value = "/etc" -> current_path_resolved = "/etc"
# 2. Relative parent path: current_word_value = "../../Program Files" -> current_path_resolved = "/c/Program Files"
# 3. Subfolder: current_word_value = "OneDrive" -> current_path_resolved = "/c/Users/awluc/OneDrive"
# 4. Subfolder of workflows dir = "OneDrive/GitHub/UMCCR/workflows/contig/" -> current path resolved
if current_word_value is not None:
    if current_word_value.endswith("/"):
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value)).resolve()
    else:
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value).parent).resolve()

else:
    current_word_value = ""
    current_path_resolved = Path(getcwd()).absolute()

# Is the current_path_resolved a subpath of the workflows directory?
try:
    _ = current_path_resolved.relative_to(get_workflows_dir())
    in_workflows_dir = True
except ValueError:
    in_workflows_dir = False

if in_workflows_dir:
    current_path_resolved_relative_to_workflows_dir = current_path_resolved.relative_to(get_workflows_dir())
    if current_path_resolved_relative_to_workflows_dir == Path("."):
        for s_path in workflow_paths:
            if current_word_value.endswith("/"):
                print(Path(current_word_value) / s_path)
            else:
                print(Path(current_word_value).parent / s_path)
    else:
        for s_path in workflow_paths:
            if str(s_path).startswith(str(current_path_resolved_relative_to_workflows_dir)):
                if current_word_value.endswith("/"):
                    print(
                        Path(current_word_value) / s_path.relative_to(current_path_resolved_relative_to_workflows_dir))
                else:
                    print(Path(current_word_value).parent / s_path.relative_to(
                        current_path_resolved_relative_to_workflows_dir))

else:
    # Now get the workflows yaml path relative to the current path
    try:
        workflows_dir = get_workflows_dir().relative_to(current_path_resolved)
    except ValueError:
        # We could be in a different mount point OR just in a subdirectory
        if str(get_workflows_dir().absolute()) in str(relpath(get_workflows_dir(), current_path_resolved)):
            # Separate mount point
            workflows_dir = get_workflows_dir().absolute()
        else:
            workflows_dir = Path(relpath(get_workflows_dir(), current_path_resolved))

    # Now iterate through paths
    for s_path in workflow_paths:
        if current_word_value.endswith("/"):
            print(Path(current_word_value) / workflows_dir.joinpath(s_path))
        else:
            print(Path(current_word_value).parent / workflows_dir.joinpath(s_path))
EOF

 ) )
    compadd -X "workflow_path:" $__dynamic_completion
}
_cwl-ica_add-workflow-to-project_option_project_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the project names in the project.yaml file
"""
from cwl_ica.utils.repo import get_project_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each project name
for project in read_yaml(get_project_yaml_path())["projects"]:
    print(project["project_name"])
EOF

 ) )
    compadd -X "project:" $__dynamic_completion
}
_cwl-ica_append-typescript-directory-to-cwl-commandline-tool_option_tool_path_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python3

"""
List the unregistered tool paths
"""

# Externals
from pathlib import Path
from os import getcwd
from os.path import relpath

# CWL ICA
from cwl_ica.utils.repo import get_tools_dir

# Get the current word value
if not "${CURRENT_WORD}" == "":
    current_word_value = "${CURRENT_WORD}"
else:
    current_word_value = None

# Resolve the current path
# If getcwd() is "/c/Users/awluc"
# 1. Non relative paths: current_word_value = "/etc" -> current_path_resolved = "/etc"
# 2. Relative parent path: current_word_value = "../../Program Files" -> current_path_resolved = "/c/Program Files"
# 3. Subfolder: current_word_value = "OneDrive" -> current_path_resolved = "/c/Users/awluc/OneDrive"
# 4. Subfolder of tools dir = "OneDrive/GitHub/UMCCR/tools/contig/" -> current path resolved
if current_word_value is not None:
    if current_word_value.endswith("/"):
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value)).resolve()
    else:
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value).parent).resolve()
else:
    current_word_value = ""
    current_path_resolved = Path(getcwd()).absolute()


# Is the current_path_resolved a subpath of the tools directory?
try:
    _ = current_path_resolved.relative_to(get_tools_dir())
    in_tools_dir = True
except ValueError:
    in_tools_dir = False

if not current_word_value == "" and in_tools_dir:
    tool_paths = [
        s_file.relative_to(get_tools_dir())
        for s_file in current_path_resolved.glob("**/*.cwl")
    ]
else:
    tool_paths = [
        s_file.relative_to(get_tools_dir())
        for s_file in get_tools_dir().glob("**/*.cwl")
    ]

if in_tools_dir:
    current_path_resolved_relative_to_tools_dir = current_path_resolved.relative_to(get_tools_dir())
    if current_path_resolved_relative_to_tools_dir == Path("."):
        for s_path in tool_paths:
            if current_word_value.endswith("/"):
                print(Path(current_word_value) / s_path)
            else:
                print(Path(current_word_value).parent / s_path)
    else:
        for s_path in tool_paths:
            if str(s_path).startswith(str(current_path_resolved_relative_to_tools_dir)):
                if current_word_value.endswith("/"):
                    print(Path(current_word_value) / s_path.relative_to(current_path_resolved_relative_to_tools_dir))
                else:
                    print(Path(current_word_value).parent / s_path.relative_to(
                        current_path_resolved_relative_to_tools_dir))

else:
    # Now get the tools yaml path relative to the current path
    try:
        tools_dir = get_tools_dir().relative_to(current_path_resolved)
    except ValueError:
        # We could be in a different mount point OR just in a subdirectory
        if str(get_tools_dir().absolute()) in str(relpath(get_tools_dir(), current_path_resolved)):
            # Separate mount point
            tools_dir = get_tools_dir().absolute()
        else:
            tools_dir = Path(relpath(get_tools_dir(), current_path_resolved))

    # Now iterate through paths
    for s_path in tool_paths:
        if current_word_value.endswith("/"):
            print(Path(current_word_value) / tools_dir.joinpath(s_path))
        else:
            print(Path(current_word_value).parent / tools_dir.joinpath(s_path))
EOF

 ) )
    compadd -X "tool_path:" $__dynamic_completion
}
_cwl-ica_append-typescript-directory-to-cwl-expression-tool_option_expression_path_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python3

"""
List the unregistered expression paths
"""

# Externals
from pathlib import Path
from os import getcwd
from os.path import relpath

# CWL ICA
from cwl_ica.utils.repo import get_expression_yaml_path
from cwl_ica.utils.repo import get_expressions_dir
from cwl_ica.utils.miscell import read_yaml

# Get the current word value
if not "${CURRENT_WORD}" == "":
    current_word_value = "${CURRENT_WORD}"
else:
    current_word_value = None

# Resolve the current path
# If getcwd() is "/c/Users/awluc"
# 1. Non relative paths: current_word_value = "/etc" -> current_path_resolved = "/etc"
# 2. Relative parent path: current_word_value = "../../Program Files" -> current_path_resolved = "/c/Program Files"
# 3. Subfolder: current_word_value = "OneDrive" -> current_path_resolved = "/c/Users/awluc/OneDrive"
# 4. Subfolder of expressions dir = "OneDrive/GitHub/UMCCR/expressions/contig/" -> current path resolved
if current_word_value is not None:
    if current_word_value.endswith("/"):
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value)).resolve()
    else:
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value).parent).resolve()

else:
    current_word_value = ""
    current_path_resolved = Path(getcwd()).absolute()

# Is the current_path_resolved a subpath of the expressions directory?
try:
    _ = current_path_resolved.relative_to(get_expressions_dir())
    in_expressions_dir = True
except ValueError:
    in_expressions_dir = False

if not current_word_value == "" and in_expressions_dir:
    expression_paths = [
        s_file.relative_to(get_expressions_dir())
        for s_file in current_path_resolved.glob("**/*.cwl")
    ]
else:
    expression_paths = [
        s_file.relative_to(get_expressions_dir())
        for s_file in get_expressions_dir().glob("**/*.cwl")
    ]

if in_expressions_dir:
    current_path_resolved_relative_to_expressions_dir = current_path_resolved.relative_to(get_expressions_dir())
    if current_path_resolved_relative_to_expressions_dir == Path("."):
        for s_path in expression_paths:
            if current_word_value.endswith("/"):
                print(Path(current_word_value) / s_path)
            else:
                print(Path(current_word_value).parent / s_path)
    else:
        for s_path in expression_paths:
            if str(s_path).startswith(str(current_path_resolved_relative_to_expressions_dir)):
                if current_word_value.endswith("/"):
                    print(Path(current_word_value) / s_path.relative_to(
                        current_path_resolved_relative_to_expressions_dir))
                else:
                    print(Path(current_word_value).parent / s_path.relative_to(
                        current_path_resolved_relative_to_expressions_dir))

else:
    # Now get the expressions yaml path relative to the current path
    try:
        expressions_dir = get_expressions_dir().relative_to(current_path_resolved)
    except ValueError:
        # We could be in a different mount point OR just in a subdirectory
        if str(get_expressions_dir().absolute()) in str(relpath(get_expressions_dir(), current_path_resolved)):
            # Separate mount point
            expressions_dir = get_expressions_dir().absolute()
        else:
            expressions_dir = Path(relpath(get_expressions_dir(), current_path_resolved))

    # Now iterate through paths
    for s_path in expression_paths:
        if current_word_value.endswith("/"):
            print(Path(current_word_value) / expressions_dir.joinpath(s_path))
        else:
            print(Path(current_word_value).parent / expressions_dir.joinpath(s_path))
EOF

 ) )
    compadd -X "expression_path:" $__dynamic_completion
}
_cwl-ica_append-typescript-directory-to-cwl-workflow_option_workflow_path_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python3

"""
List the unregistered workflow paths
"""

# Externals
from pathlib import Path
from os import getcwd
from os.path import relpath

# CWL ICA
from cwl_ica.utils.repo import get_workflows_dir

# Get the current word value
if not "${CURRENT_WORD}" == "":
    current_word_value = "${CURRENT_WORD}"
else:
    current_word_value = None

# Resolve the current path
# If getcwd() is "/c/Users/awluc"
# 1. Non relative paths: current_word_value = "/etc" -> current_path_resolved = "/etc"
# 2. Relative parent path: current_word_value = "../../Program Files" -> current_path_resolved = "/c/Program Files"
# 3. Subfolder: current_word_value = "OneDrive" -> current_path_resolved = "/c/Users/awluc/OneDrive"
# 4. Subfolder of workflows dir = "OneDrive/GitHub/UMCCR/workflows/contig/" -> current path resolved
if current_word_value is not None:
    if current_word_value.endswith("/"):
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value)).resolve()
    else:
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value).parent).resolve()
else:
    current_word_value = ""
    current_path_resolved = Path(getcwd()).absolute()


# Is the current_path_resolved a subpath of the workflows directory?
try:
    _ = current_path_resolved.relative_to(get_workflows_dir())
    in_workflows_dir = True
except ValueError:
    in_workflows_dir = False

if not current_word_value == "" and in_workflows_dir:
    workflow_paths = [
        s_file.relative_to(get_workflows_dir())
        for s_file in current_path_resolved.glob("**/*.cwl")
    ]
else:
    workflow_paths = [
        s_file.relative_to(get_workflows_dir())
        for s_file in get_workflows_dir().glob("**/*.cwl")
    ]

if in_workflows_dir:
    current_path_resolved_relative_to_workflows_dir = current_path_resolved.relative_to(get_workflows_dir())
    if current_path_resolved_relative_to_workflows_dir == Path("."):
        for s_path in workflow_paths:
            if current_word_value.endswith("/"):
                print(Path(current_word_value) / s_path)
            else:
                print(Path(current_word_value).parent / s_path)
    else:
        for s_path in workflow_paths:
            if str(s_path).startswith(str(current_path_resolved_relative_to_workflows_dir)):
                if current_word_value.endswith("/"):
                    print(
                        Path(current_word_value) / s_path.relative_to(current_path_resolved_relative_to_workflows_dir))
                else:
                    print(Path(current_word_value).parent / s_path.relative_to(
                        current_path_resolved_relative_to_workflows_dir))

else:
    # Now get the workflows yaml path relative to the current path
    try:
        workflows_dir = get_workflows_dir().relative_to(current_path_resolved)
    except ValueError:
        # We could be in a different mount point OR just in a subdirectory
        if str(get_workflows_dir().absolute()) in str(relpath(get_workflows_dir(), current_path_resolved)):
            # Separate mount point
            workflows_dir = get_workflows_dir().absolute()
        else:
            workflows_dir = Path(relpath(get_workflows_dir(), current_path_resolved))

    # Now iterate through paths
    for s_path in workflow_paths:
        if current_word_value.endswith("/"):
            print(Path(current_word_value) / workflows_dir.joinpath(s_path))
        else:
            print(Path(current_word_value).parent / workflows_dir.joinpath(s_path))
EOF

 ) )
    compadd -X "workflow_path:" $__dynamic_completion
}
_cwl-ica_copy-tool-submission-template_option_ica_workflow_run_instance_id_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the run instance ids in the run.yaml file
"""
# CWL ICA imports
from cwl_ica.utils.repo import get_run_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each run instance id
for run in read_yaml(get_run_yaml_path())["runs"]:
    print(run.get("ica_workflow_run_instance_id"))
EOF

 ) )
    compadd -X "ica_workflow_run_instance_id:" $__dynamic_completion
}
_cwl-ica_copy-workflow-submission-template_option_ica_workflow_run_instance_id_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the run instance ids in the run.yaml file
"""
# CWL ICA imports
from cwl_ica.utils.repo import get_run_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each run instance id
for run in read_yaml(get_run_yaml_path())["runs"]:
    print(run.get("ica_workflow_run_instance_id"))
EOF

 ) )
    compadd -X "ica_workflow_run_instance_id:" $__dynamic_completion
}
_cwl-ica_create-expression-from-template_option_username_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the category names in the categories.yaml file
"""
# CWL ICA imports
from cwl_ica.utils.repo import get_user_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each project name
for user in read_yaml(get_user_yaml_path())["users"]:
    print(user["username"])
EOF

 ) )
    compadd -X "username:" $__dynamic_completion
}
_cwl-ica_create-tool-from-template_option_username_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the category names in the categories.yaml file
"""
# CWL ICA imports
from cwl_ica.utils.repo import get_user_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each project name
for user in read_yaml(get_user_yaml_path())["users"]:
    print(user["username"])
EOF

 ) )
    compadd -X "username:" $__dynamic_completion
}
_cwl-ica_create-tool-submission-template_option_tool_path_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python3

"""
List the unregistered tool paths
"""

# Externals
from pathlib import Path
from os import getcwd
from os.path import relpath

# CWL ICA
from cwl_ica.utils.repo import get_tools_dir

# Get the current word value
if not "${CURRENT_WORD}" == "":
    current_word_value = "${CURRENT_WORD}"
else:
    current_word_value = None

# Resolve the current path
# If getcwd() is "/c/Users/awluc"
# 1. Non relative paths: current_word_value = "/etc" -> current_path_resolved = "/etc"
# 2. Relative parent path: current_word_value = "../../Program Files" -> current_path_resolved = "/c/Program Files"
# 3. Subfolder: current_word_value = "OneDrive" -> current_path_resolved = "/c/Users/awluc/OneDrive"
# 4. Subfolder of tools dir = "OneDrive/GitHub/UMCCR/tools/contig/" -> current path resolved
if current_word_value is not None:
    if current_word_value.endswith("/"):
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value)).resolve()
    else:
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value).parent).resolve()
else:
    current_word_value = ""
    current_path_resolved = Path(getcwd()).absolute()


# Is the current_path_resolved a subpath of the tools directory?
try:
    _ = current_path_resolved.relative_to(get_tools_dir())
    in_tools_dir = True
except ValueError:
    in_tools_dir = False

if not current_word_value == "" and in_tools_dir:
    tool_paths = [
        s_file.relative_to(get_tools_dir())
        for s_file in current_path_resolved.glob("**/*.cwl")
    ]
else:
    tool_paths = [
        s_file.relative_to(get_tools_dir())
        for s_file in get_tools_dir().glob("**/*.cwl")
    ]

if in_tools_dir:
    current_path_resolved_relative_to_tools_dir = current_path_resolved.relative_to(get_tools_dir())
    if current_path_resolved_relative_to_tools_dir == Path("."):
        for s_path in tool_paths:
            if current_word_value.endswith("/"):
                print(Path(current_word_value) / s_path)
            else:
                print(Path(current_word_value).parent / s_path)
    else:
        for s_path in tool_paths:
            if str(s_path).startswith(str(current_path_resolved_relative_to_tools_dir)):
                if current_word_value.endswith("/"):
                    print(Path(current_word_value) / s_path.relative_to(current_path_resolved_relative_to_tools_dir))
                else:
                    print(Path(current_word_value).parent / s_path.relative_to(
                        current_path_resolved_relative_to_tools_dir))

else:
    # Now get the tools yaml path relative to the current path
    try:
        tools_dir = get_tools_dir().relative_to(current_path_resolved)
    except ValueError:
        # We could be in a different mount point OR just in a subdirectory
        if str(get_tools_dir().absolute()) in str(relpath(get_tools_dir(), current_path_resolved)):
            # Separate mount point
            tools_dir = get_tools_dir().absolute()
        else:
            tools_dir = Path(relpath(get_tools_dir(), current_path_resolved))

    # Now iterate through paths
    for s_path in tool_paths:
        if current_word_value.endswith("/"):
            print(Path(current_word_value) / tools_dir.joinpath(s_path))
        else:
            print(Path(current_word_value).parent / tools_dir.joinpath(s_path))
EOF

 ) )
    compadd -X "tool_path:" $__dynamic_completion
}
_cwl-ica_create-tool-submission-template_option_project_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the project names in the project.yaml file
"""
from cwl_ica.utils.repo import get_project_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each project name
for project in read_yaml(get_project_yaml_path())["projects"]:
    print(project["project_name"])
EOF

 ) )
    compadd -X "project:" $__dynamic_completion
}
_cwl-ica_create-tool-submission-template_option_gds_prefix_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
bash - <<EOF
  __cwl-ica_list_gds_folders.sh
EOF

 ) )
    compadd -X "gds_prefix:" $__dynamic_completion
}
_cwl-ica_create-tool-submission-template_option_gds_work_prefix_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
bash - <<EOF
  __cwl-ica_list_gds_folders.sh
EOF

 ) )
    compadd -X "gds_work_prefix:" $__dynamic_completion
}
_cwl-ica_create-tool-submission-template_option_gds_output_prefix_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
bash - <<EOF
  __cwl-ica_list_gds_folders.sh
EOF

 ) )
    compadd -X "gds_output_prefix:" $__dynamic_completion
}
_cwl-ica_create-tool-submission-template_option_gds_work_directory_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
bash - <<EOF
  __cwl-ica_list_gds_folders.sh
EOF

 ) )
    compadd -X "gds_work_directory:" $__dynamic_completion
}
_cwl-ica_create-tool-submission-template_option_gds_output_directory_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
bash - <<EOF
  __cwl-ica_list_gds_folders.sh
EOF

 ) )
    compadd -X "gds_output_directory:" $__dynamic_completion
}
_cwl-ica_create-typescript-expression-from-template_option_username_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the category names in the categories.yaml file
"""
# CWL ICA imports
from cwl_ica.utils.repo import get_user_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each project name
for user in read_yaml(get_user_yaml_path())["users"]:
    print(user["username"])
EOF

 ) )
    compadd -X "username:" $__dynamic_completion
}
_cwl-ica_create-typescript-interface-from-cwl-schema_option_schema_path_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python3

"""
List the unregistered schema paths
"""

# Externals
from pathlib import Path
from os import getcwd
from os.path import relpath

# CWL ICA
from cwl_ica.utils.repo import get_schemas_dir

# Get the current word value
if not "${CURRENT_WORD-}" == "":
    current_word_value = "${CURRENT_WORD}"
else:
    current_word_value = None

# Resolve the current path
# If getcwd() is "/c/Users/awluc"
# 1. Non relative paths: current_word_value = "/etc" -> current_path_resolved = "/etc"
# 2. Relative parent path: current_word_value = "../../Program Files" -> current_path_resolved = "/c/Program Files"
# 3. Subfolder: current_word_value = "OneDrive" -> current_path_resolved = "/c/Users/awluc/OneDrive"
# 4. Subfolder of schemas dir = "OneDrive/GitHub/UMCCR/schemas/contig/" -> current path resolved
if current_word_value is not None:
    if current_word_value.endswith("/"):
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value)).resolve()
    else:
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value).parent).resolve()
else:
    current_word_value = ""
    current_path_resolved = Path(getcwd()).absolute()

# Is the current_path_resolved a subpath of the schemas directory?
try:
    _ = current_path_resolved.relative_to(get_schemas_dir())
    in_schemas_dir = True
except ValueError:
    in_schemas_dir = False

if not current_word_value == "" and in_schemas_dir:
    schema_paths = [
        s_file.relative_to(get_schemas_dir())
        for s_file in current_path_resolved.glob("**/*.yaml")
    ]
else:
    schema_paths = [
        s_file.relative_to(get_schemas_dir())
        for s_file in get_schemas_dir().glob("**/*.yaml")
    ]

if in_schemas_dir:
    current_path_resolved_relative_to_schemas_dir = current_path_resolved.relative_to(get_schemas_dir())
    if current_path_resolved_relative_to_schemas_dir == Path("."):
        for s_path in schema_paths:
            if current_word_value.endswith("/"):
                print(Path(current_word_value) / s_path)
            else:
                print(Path(current_word_value).parent / s_path)
    else:
        for s_path in schema_paths:
            if str(s_path).startswith(str(current_path_resolved_relative_to_schemas_dir)):
                if current_word_value.endswith("/"):
                    print(Path(current_word_value) / s_path.relative_to(
                        current_path_resolved_relative_to_schemas_dir))
                else:
                    print(Path(current_word_value).parent / s_path.relative_to(
                        current_path_resolved_relative_to_schemas_dir))

else:
    # Now get the schemas yaml path relative to the current path
    try:
        schemas_dir = get_schemas_dir().relative_to(current_path_resolved)
    except ValueError:
        # We could be in a different mount point OR just in a subdirectory
        if str(get_schemas_dir().absolute()) in str(relpath(get_schemas_dir(), current_path_resolved)):
            # Separate mount point
            schemas_dir = get_schemas_dir().absolute()
        else:
            schemas_dir = Path(relpath(get_schemas_dir(), current_path_resolved))

    # Now iterate through paths
    for s_path in schema_paths:
        if current_word_value.endswith("/"):
            print(Path(current_word_value) / schemas_dir.joinpath(s_path))
        else:
            print(Path(current_word_value).parent / schemas_dir.joinpath(s_path))
EOF

 ) )
    compadd -X "schema_path:" $__dynamic_completion
}
_cwl-ica_create-workflow-from-template_option_username_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the category names in the categories.yaml file
"""
# CWL ICA imports
from cwl_ica.utils.repo import get_user_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each project name
for user in read_yaml(get_user_yaml_path())["users"]:
    print(user["username"])
EOF

 ) )
    compadd -X "username:" $__dynamic_completion
}
_cwl-ica_create-workflow-submission-template_option_workflow_path_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python3

"""
List the unregistered workflow paths
"""

# Externals
from pathlib import Path
from os import getcwd
from os.path import relpath

# CWL ICA
from cwl_ica.utils.repo import get_workflows_dir

# Get the current word value
if not "${CURRENT_WORD}" == "":
    current_word_value = "${CURRENT_WORD}"
else:
    current_word_value = None

# Resolve the current path
# If getcwd() is "/c/Users/awluc"
# 1. Non relative paths: current_word_value = "/etc" -> current_path_resolved = "/etc"
# 2. Relative parent path: current_word_value = "../../Program Files" -> current_path_resolved = "/c/Program Files"
# 3. Subfolder: current_word_value = "OneDrive" -> current_path_resolved = "/c/Users/awluc/OneDrive"
# 4. Subfolder of workflows dir = "OneDrive/GitHub/UMCCR/workflows/contig/" -> current path resolved
if current_word_value is not None:
    if current_word_value.endswith("/"):
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value)).resolve()
    else:
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value).parent).resolve()
else:
    current_word_value = ""
    current_path_resolved = Path(getcwd()).absolute()


# Is the current_path_resolved a subpath of the workflows directory?
try:
    _ = current_path_resolved.relative_to(get_workflows_dir())
    in_workflows_dir = True
except ValueError:
    in_workflows_dir = False

if not current_word_value == "" and in_workflows_dir:
    workflow_paths = [
        s_file.relative_to(get_workflows_dir())
        for s_file in current_path_resolved.glob("**/*.cwl")
    ]
else:
    workflow_paths = [
        s_file.relative_to(get_workflows_dir())
        for s_file in get_workflows_dir().glob("**/*.cwl")
    ]

if in_workflows_dir:
    current_path_resolved_relative_to_workflows_dir = current_path_resolved.relative_to(get_workflows_dir())
    if current_path_resolved_relative_to_workflows_dir == Path("."):
        for s_path in workflow_paths:
            if current_word_value.endswith("/"):
                print(Path(current_word_value) / s_path)
            else:
                print(Path(current_word_value).parent / s_path)
    else:
        for s_path in workflow_paths:
            if str(s_path).startswith(str(current_path_resolved_relative_to_workflows_dir)):
                if current_word_value.endswith("/"):
                    print(
                        Path(current_word_value) / s_path.relative_to(current_path_resolved_relative_to_workflows_dir))
                else:
                    print(Path(current_word_value).parent / s_path.relative_to(
                        current_path_resolved_relative_to_workflows_dir))

else:
    # Now get the workflows yaml path relative to the current path
    try:
        workflows_dir = get_workflows_dir().relative_to(current_path_resolved)
    except ValueError:
        # We could be in a different mount point OR just in a subdirectory
        if str(get_workflows_dir().absolute()) in str(relpath(get_workflows_dir(), current_path_resolved)):
            # Separate mount point
            workflows_dir = get_workflows_dir().absolute()
        else:
            workflows_dir = Path(relpath(get_workflows_dir(), current_path_resolved))

    # Now iterate through paths
    for s_path in workflow_paths:
        if current_word_value.endswith("/"):
            print(Path(current_word_value) / workflows_dir.joinpath(s_path))
        else:
            print(Path(current_word_value).parent / workflows_dir.joinpath(s_path))
EOF

 ) )
    compadd -X "workflow_path:" $__dynamic_completion
}
_cwl-ica_create-workflow-submission-template_option_project_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the project names in the project.yaml file
"""
from cwl_ica.utils.repo import get_project_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each project name
for project in read_yaml(get_project_yaml_path())["projects"]:
    print(project["project_name"])
EOF

 ) )
    compadd -X "project:" $__dynamic_completion
}
_cwl-ica_create-workflow-submission-template_option_gds_prefix_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
if [[ -n "${ICA_ACCESS_TOKEN-}" && -n "${ICA_BASE_URL}" ]]; then
  volume_name="$(python -c "from urllib.parse import urlparse; print(urlparse(\"${CURRENT_WORD}\").netloc)")";
  path="$(python -c "from urllib.parse import urlparse; print(urlparse(\"${CURRENT_WORD}\").path)")";
  if [[ -z "${volume_name}" || -z "${path}" ]]; then
    curl --fail --silent --location \
      --request GET \
      --header "Accept: application/json" \
      --header "Authorization: Bearer ${ICA_ACCESS_TOKEN}" \
      --url "${ICA_BASE_URL}/v1/volumes?pageSize=1000" | \
    jq --raw-output \
      '
        .items |
        map("gds://\(.name)/") |
        .[]
      ';
  else
    curl --fail --silent --location \
      --request GET \
      --header "Accept: application/json" \
      --header "Authorization: Bearer ${ICA_ACCESS_TOKEN}" \
      --url "${ICA_BASE_URL}/v1/folders?volume.name=${volume_name}&pageSize=1000&recursive=false&path=${path}*" | \
    jq --raw-output \
      '
        .items |
        map("gds://\(.volumeName)\(.path)") |
        .[]
      ';
  fi
fi

 ) )
    compadd -X "gds_prefix:" $__dynamic_completion
}
_cwl-ica_create-workflow-submission-template_option_gds_work_prefix_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
if [[ -n "${ICA_ACCESS_TOKEN-}" && -n "${ICA_BASE_URL}" ]]; then
  volume_name="$(python -c "from urllib.parse import urlparse; print(urlparse(\"${CURRENT_WORD}\").netloc)")";
  path="$(python -c "from urllib.parse import urlparse; print(urlparse(\"${CURRENT_WORD}\").path)")";
  if [[ -z "${volume_name}" || -z "${path}" ]]; then
    curl --fail --silent --location \
      --request GET \
      --header "Accept: application/json" \
      --header "Authorization: Bearer ${ICA_ACCESS_TOKEN}" \
      --url "${ICA_BASE_URL}/v1/volumes?pageSize=1000" | \
    jq --raw-output \
      '
        .items |
        map("gds://\(.name)/") |
        .[]
      ';
  else
    curl --fail --silent --location \
      --request GET \
      --header "Accept: application/json" \
      --header "Authorization: Bearer ${ICA_ACCESS_TOKEN}" \
      --url "${ICA_BASE_URL}/v1/folders?volume.name=${volume_name}&pageSize=1000&recursive=false&path=${path}*" | \
    jq --raw-output \
      '
        .items |
        map("gds://\(.volumeName)\(.path)") |
        .[]
      ';
  fi
fi

 ) )
    compadd -X "gds_work_prefix:" $__dynamic_completion
}
_cwl-ica_create-workflow-submission-template_option_gds_output_prefix_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
if [[ -n "${ICA_ACCESS_TOKEN-}" && -n "${ICA_BASE_URL}" ]]; then
  volume_name="$(python -c "from urllib.parse import urlparse; print(urlparse(\"${CURRENT_WORD}\").netloc)")";
  path="$(python -c "from urllib.parse import urlparse; print(urlparse(\"${CURRENT_WORD}\").path)")";
  if [[ -z "${volume_name}" || -z "${path}" ]]; then
    curl --fail --silent --location \
      --request GET \
      --header "Accept: application/json" \
      --header "Authorization: Bearer ${ICA_ACCESS_TOKEN}" \
      --url "${ICA_BASE_URL}/v1/volumes?pageSize=1000" | \
    jq --raw-output \
      '
        .items |
        map("gds://\(.name)/") |
        .[]
      ';
  else
    curl --fail --silent --location \
      --request GET \
      --header "Accept: application/json" \
      --header "Authorization: Bearer ${ICA_ACCESS_TOKEN}" \
      --url "${ICA_BASE_URL}/v1/folders?volume.name=${volume_name}&pageSize=1000&recursive=false&path=${path}*" | \
    jq --raw-output \
      '
        .items |
        map("gds://\(.volumeName)\(.path)") |
        .[]
      ';
  fi
fi

 ) )
    compadd -X "gds_output_prefix:" $__dynamic_completion
}
_cwl-ica_create-workflow-submission-template_option_gds_work_directory_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
if [[ -n "${ICA_ACCESS_TOKEN-}" && -n "${ICA_BASE_URL}" ]]; then
  volume_name="$(python -c "from urllib.parse import urlparse; print(urlparse(\"${CURRENT_WORD}\").netloc)")";
  path="$(python -c "from urllib.parse import urlparse; print(urlparse(\"${CURRENT_WORD}\").path)")";
  if [[ -z "${volume_name}" || -z "${path}" ]]; then
    curl --fail --silent --location \
      --request GET \
      --header "Accept: application/json" \
      --header "Authorization: Bearer ${ICA_ACCESS_TOKEN}" \
      --url "${ICA_BASE_URL}/v1/volumes?pageSize=1000" | \
    jq --raw-output \
      '
        .items |
        map("gds://\(.name)/") |
        .[]
      ';
  else
    curl --fail --silent --location \
      --request GET \
      --header "Accept: application/json" \
      --header "Authorization: Bearer ${ICA_ACCESS_TOKEN}" \
      --url "${ICA_BASE_URL}/v1/folders?volume.name=${volume_name}&pageSize=1000&recursive=false&path=${path}*" | \
    jq --raw-output \
      '
        .items |
        map("gds://\(.volumeName)\(.path)") |
        .[]
      ';
  fi
fi

 ) )
    compadd -X "gds_work_directory:" $__dynamic_completion
}
_cwl-ica_create-workflow-submission-template_option_gds_output_directory_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
if [[ -n "${ICA_ACCESS_TOKEN-}" && -n "${ICA_BASE_URL}" ]]; then
  volume_name="$(python -c "from urllib.parse import urlparse; print(urlparse(\"${CURRENT_WORD}\").netloc)")";
  path="$(python -c "from urllib.parse import urlparse; print(urlparse(\"${CURRENT_WORD}\").path)")";
  if [[ -z "${volume_name}" || -z "${path}" ]]; then
    curl --fail --silent --location \
      --request GET \
      --header "Accept: application/json" \
      --header "Authorization: Bearer ${ICA_ACCESS_TOKEN}" \
      --url "${ICA_BASE_URL}/v1/volumes?pageSize=1000" | \
    jq --raw-output \
      '
        .items |
        map("gds://\(.name)/") |
        .[]
      ';
  else
    curl --fail --silent --location \
      --request GET \
      --header "Accept: application/json" \
      --header "Authorization: Bearer ${ICA_ACCESS_TOKEN}" \
      --url "${ICA_BASE_URL}/v1/folders?volume.name=${volume_name}&pageSize=1000&recursive=false&path=${path}*" | \
    jq --raw-output \
      '
        .items |
        map("gds://\(.volumeName)\(.path)") |
        .[]
      ';
  fi
fi

 ) )
    compadd -X "gds_output_directory:" $__dynamic_completion
}
_cwl-ica_expression-init_option_expression_path_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python3

"""
List the unregistered expression paths
"""

# External
from pathlib import Path
from os import getcwd
from os.path import relpath

# CWL ICA imports
from cwl_ica.utils.repo import get_expression_yaml_path
from cwl_ica.utils.repo import get_expressions_dir
from cwl_ica.utils.miscell import read_yaml

registered_expression_paths = [
    Path(expression["path"]) / Path(version["path"])
    for expression in read_yaml(get_expression_yaml_path())["expressions"]
    for version in expression["versions"]
]

# Get the current word value
if not "${CURRENT_WORD}" == "":
    current_word_value = "${CURRENT_WORD}"
else:
    current_word_value = None

# Resolve the current path
# If getcwd() is "/c/Users/awluc"
# 1. Non relative paths: current_word_value = "/etc" -> current_path_resolved = "/etc"
# 2. Relative parent path: current_word_value = "../../Program Files" -> current_path_resolved = "/c/Program Files"
# 3. Subfolder: current_word_value = "OneDrive" -> current_path_resolved = "/c/Users/awluc/OneDrive"
# 4. Subfolder of expressions dir = "OneDrive/GitHub/UMCCR/expressions/contig/" -> current path resolved
if current_word_value is not None:
    if current_word_value.endswith("/"):
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value)).resolve()
    else:
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value).parent).resolve()
else:
    current_word_value = ""
    current_path_resolved = Path(getcwd()).absolute()

# Is the current_path_resolved a subpath of the expressions directory?
try:
    _ = current_path_resolved.relative_to(get_expressions_dir())
    in_expressions_dir = True
except ValueError:
    in_expressions_dir = False

if not current_word_value == "" and in_expressions_dir:
    all_paths = [
        s_file.relative_to(get_expressions_dir())
        for s_file in current_path_resolved.glob("**/*.cwl")
    ]
else:
    all_paths = [
        s_file.relative_to(get_expressions_dir())
        for s_file in get_expressions_dir().glob("**/*.cwl")
    ]

expression_paths = [
    a_path
    for a_path in all_paths
    if a_path not in registered_expression_paths
]

if in_expressions_dir:
    current_path_resolved_relative_to_expressions_dir = current_path_resolved.relative_to(get_expressions_dir())
    if current_path_resolved_relative_to_expressions_dir == Path("."):
        for s_path in expression_paths:
            if current_word_value.endswith("/"):
                print(Path(current_word_value) / s_path)
            else:
                print(Path(current_word_value).parent / s_path)
    else:
        for s_path in expression_paths:
            if str(s_path).startswith(str(current_path_resolved_relative_to_expressions_dir)):
                if current_word_value.endswith("/"):
                    print(Path(current_word_value) / s_path.relative_to(
                        current_path_resolved_relative_to_expressions_dir))
                else:
                    print(Path(current_word_value).parent / s_path.relative_to(
                        current_path_resolved_relative_to_expressions_dir))

else:
    # Now get the expressions yaml path relative to the current path
    try:
        expressions_dir = get_expressions_dir().relative_to(current_path_resolved)
    except ValueError:
        # We could be in a different mount point OR just in a subdirectory
        if str(get_expressions_dir().absolute()) in str(relpath(get_expressions_dir(), current_path_resolved)):
            # Separate mount point
            expressions_dir = get_expressions_dir().absolute()
        else:
            expressions_dir = Path(relpath(get_expressions_dir(), current_path_resolved))

    # Now iterate through paths
    for s_path in expression_paths:
        if current_word_value.endswith("/"):
            print(Path(current_word_value) / expressions_dir.joinpath(s_path))
        else:
            print(Path(current_word_value).parent / expressions_dir.joinpath(s_path))
EOF

 ) )
    compadd -X "expression_path:" $__dynamic_completion
}
_cwl-ica_expression-sync_option_expression_path_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python3

"""
List the registered expression paths
"""

# Externals
from pathlib import Path
from os import getcwd
from os.path import relpath

# CWL ICA
from cwl_ica.utils.repo import get_expression_yaml_path, read_yaml, get_expressions_dir

expression_paths = [
    Path(expression["path"]) / Path(version["path"])
    for expression in read_yaml(get_expression_yaml_path())["expressions"]
    for version in expression["versions"]
]

# Get the current word value
if not "${CURRENT_WORD}" == "":
    current_word_value = "${CURRENT_WORD}"
else:
    current_word_value = None

# Resolve the current path
# If getcwd() is "/c/Users/awluc"
# 1. Non relative paths: current_word_value = "/etc" -> current_path_resolved = "/etc"
# 2. Relative parent path: current_word_value = "../../Program Files" -> current_path_resolved = "/c/Program Files"
# 3. Subfolder: current_word_value = "OneDrive" -> current_path_resolved = "/c/Users/awluc/OneDrive"
# 4. Subfolder of expressions dir = "OneDrive/GitHub/UMCCR/expressions/contig/" -> current path resolved
if current_word_value is not None:
    if current_word_value.endswith("/"):
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value)).resolve()
    else:
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value).parent).resolve()

else:
    current_word_value = ""
    current_path_resolved = Path(getcwd()).absolute()

# Is the current_path_resolved a subpath of the expressions directory?
try:
    _ = current_path_resolved.relative_to(get_expressions_dir())
    in_expressions_dir = True
except ValueError:
    in_expressions_dir = False

if in_expressions_dir:
    current_path_resolved_relative_to_expressions_dir = current_path_resolved.relative_to(get_expressions_dir())
    if current_path_resolved_relative_to_expressions_dir == Path("."):
        for s_path in expression_paths:
            if current_word_value.endswith("/"):
                print(Path(current_word_value) / s_path)
            else:
                print(Path(current_word_value).parent / s_path)
    else:
        for s_path in expression_paths:
            if str(s_path).startswith(str(current_path_resolved_relative_to_expressions_dir)):
                if current_word_value.endswith("/"):
                    print(Path(current_word_value) / s_path.relative_to(current_path_resolved_relative_to_expressions_dir))
                else:
                    print(Path(current_word_value).parent / s_path.relative_to(current_path_resolved_relative_to_expressions_dir))

else:
    # Now get the expressions yaml path relative to the current path
    try:
        expressions_dir = get_expressions_dir().relative_to(current_path_resolved)
    except ValueError:
        # We could be in a different mount point OR just in a subdirectory
        if str(get_expressions_dir().absolute()) in str(relpath(get_expressions_dir(), current_path_resolved)):
            # Separate mount point
            expressions_dir = get_expressions_dir().absolute()
        else:
            expressions_dir = Path(relpath(get_expressions_dir(), current_path_resolved))

    # Now iterate through paths
    for s_path in expression_paths:
        if current_word_value.endswith("/"):
            print(Path(current_word_value) / expressions_dir.joinpath(s_path))
        else:
            print(Path(current_word_value).parent / expressions_dir.joinpath(s_path))
EOF

 ) )
    compadd -X "expression_path:" $__dynamic_completion
}
_cwl-ica_expression-validate_option_expression_path_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python3

"""
List the registered expression paths
"""

# Externals
from pathlib import Path
from os import getcwd
from os.path import relpath

# CWL ICA
from cwl_ica.utils.repo import get_expression_yaml_path, read_yaml, get_expressions_dir

expression_paths = [
    Path(expression["path"]) / Path(version["path"])
    for expression in read_yaml(get_expression_yaml_path())["expressions"]
    for version in expression["versions"]
]

# Get the current word value
if not "${CURRENT_WORD}" == "":
    current_word_value = "${CURRENT_WORD}"
else:
    current_word_value = None

# Resolve the current path
# If getcwd() is "/c/Users/awluc"
# 1. Non relative paths: current_word_value = "/etc" -> current_path_resolved = "/etc"
# 2. Relative parent path: current_word_value = "../../Program Files" -> current_path_resolved = "/c/Program Files"
# 3. Subfolder: current_word_value = "OneDrive" -> current_path_resolved = "/c/Users/awluc/OneDrive"
# 4. Subfolder of expressions dir = "OneDrive/GitHub/UMCCR/expressions/contig/" -> current path resolved
if current_word_value is not None:
    if current_word_value.endswith("/"):
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value)).resolve()
    else:
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value).parent).resolve()

else:
    current_word_value = ""
    current_path_resolved = Path(getcwd()).absolute()

# Is the current_path_resolved a subpath of the expressions directory?
try:
    _ = current_path_resolved.relative_to(get_expressions_dir())
    in_expressions_dir = True
except ValueError:
    in_expressions_dir = False

if in_expressions_dir:
    current_path_resolved_relative_to_expressions_dir = current_path_resolved.relative_to(get_expressions_dir())
    if current_path_resolved_relative_to_expressions_dir == Path("."):
        for s_path in expression_paths:
            if current_word_value.endswith("/"):
                print(Path(current_word_value) / s_path)
            else:
                print(Path(current_word_value).parent / s_path)
    else:
        for s_path in expression_paths:
            if str(s_path).startswith(str(current_path_resolved_relative_to_expressions_dir)):
                if current_word_value.endswith("/"):
                    print(Path(current_word_value) / s_path.relative_to(current_path_resolved_relative_to_expressions_dir))
                else:
                    print(Path(current_word_value).parent / s_path.relative_to(current_path_resolved_relative_to_expressions_dir))

else:
    # Now get the expressions yaml path relative to the current path
    try:
        expressions_dir = get_expressions_dir().relative_to(current_path_resolved)
    except ValueError:
        # We could be in a different mount point OR just in a subdirectory
        if str(get_expressions_dir().absolute()) in str(relpath(get_expressions_dir(), current_path_resolved)):
            # Separate mount point
            expressions_dir = get_expressions_dir().absolute()
        else:
            expressions_dir = Path(relpath(get_expressions_dir(), current_path_resolved))

    # Now iterate through paths
    for s_path in expression_paths:
        if current_word_value.endswith("/"):
            print(Path(current_word_value) / expressions_dir.joinpath(s_path))
        else:
            print(Path(current_word_value).parent / expressions_dir.joinpath(s_path))
EOF

 ) )
    compadd -X "expression_path:" $__dynamic_completion
}
_cwl-ica_get-workflow-step-ids_option_workflow_path_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python3

"""
List the unregistered workflow paths
"""

# Externals
from pathlib import Path
from os import getcwd
from os.path import relpath

# CWL ICA
from cwl_ica.utils.repo import get_workflows_dir

# Get the current word value
if not "${CURRENT_WORD}" == "":
    current_word_value = "${CURRENT_WORD}"
else:
    current_word_value = None

# Resolve the current path
# If getcwd() is "/c/Users/awluc"
# 1. Non relative paths: current_word_value = "/etc" -> current_path_resolved = "/etc"
# 2. Relative parent path: current_word_value = "../../Program Files" -> current_path_resolved = "/c/Program Files"
# 3. Subfolder: current_word_value = "OneDrive" -> current_path_resolved = "/c/Users/awluc/OneDrive"
# 4. Subfolder of workflows dir = "OneDrive/GitHub/UMCCR/workflows/contig/" -> current path resolved
if current_word_value is not None:
    if current_word_value.endswith("/"):
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value)).resolve()
    else:
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value).parent).resolve()
else:
    current_word_value = ""
    current_path_resolved = Path(getcwd()).absolute()


# Is the current_path_resolved a subpath of the workflows directory?
try:
    _ = current_path_resolved.relative_to(get_workflows_dir())
    in_workflows_dir = True
except ValueError:
    in_workflows_dir = False

if not current_word_value == "" and in_workflows_dir:
    workflow_paths = [
        s_file.relative_to(get_workflows_dir())
        for s_file in current_path_resolved.glob("**/*.cwl")
    ]
else:
    workflow_paths = [
        s_file.relative_to(get_workflows_dir())
        for s_file in get_workflows_dir().glob("**/*.cwl")
    ]

if in_workflows_dir:
    current_path_resolved_relative_to_workflows_dir = current_path_resolved.relative_to(get_workflows_dir())
    if current_path_resolved_relative_to_workflows_dir == Path("."):
        for s_path in workflow_paths:
            if current_word_value.endswith("/"):
                print(Path(current_word_value) / s_path)
            else:
                print(Path(current_word_value).parent / s_path)
    else:
        for s_path in workflow_paths:
            if str(s_path).startswith(str(current_path_resolved_relative_to_workflows_dir)):
                if current_word_value.endswith("/"):
                    print(
                        Path(current_word_value) / s_path.relative_to(current_path_resolved_relative_to_workflows_dir))
                else:
                    print(Path(current_word_value).parent / s_path.relative_to(
                        current_path_resolved_relative_to_workflows_dir))

else:
    # Now get the workflows yaml path relative to the current path
    try:
        workflows_dir = get_workflows_dir().relative_to(current_path_resolved)
    except ValueError:
        # We could be in a different mount point OR just in a subdirectory
        if str(get_workflows_dir().absolute()) in str(relpath(get_workflows_dir(), current_path_resolved)):
            # Separate mount point
            workflows_dir = get_workflows_dir().absolute()
        else:
            workflows_dir = Path(relpath(get_workflows_dir(), current_path_resolved))

    # Now iterate through paths
    for s_path in workflow_paths:
        if current_word_value.endswith("/"):
            print(Path(current_word_value) / workflows_dir.joinpath(s_path))
        else:
            print(Path(current_word_value).parent / workflows_dir.joinpath(s_path))
EOF

 ) )
    compadd -X "workflow_path:" $__dynamic_completion
}
_cwl-ica_icav2-deploy-pipeline_option_project_id_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
if [[ -n "${ICAV2_ACCESS_TOKEN-}" ]]; then
  curl --silent --fail --location --request "GET" \
       --url "https://${ICAV2_BASE_URL-ica.illumina.com}/ica/rest/api/projects" \
       --header 'Accept: application/vnd.illumina.v3+json' \
       --header "Authorization: Bearer ${ICAV2_ACCESS_TOKEN}" | \
  jq --raw-output '.items[] | .id'
fi
 ) )
    compadd -X "project_id:" $__dynamic_completion
}
_cwl-ica_icav2-deploy-pipeline_option_project_name_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
if [[ -n "${ICAV2_ACCESS_TOKEN-}" ]]; then
  curl --silent --fail --location --request "GET" \
       --url "https://${ICAV2_BASE_URL-ica.illumina.com}/ica/rest/api/projects" \
       --header 'Accept: application/vnd.illumina.v3+json' \
       --header "Authorization: Bearer ${ICAV2_ACCESS_TOKEN}" | \
  jq --raw-output '.items[] | .name'
fi
 ) )
    compadd -X "project_name:" $__dynamic_completion
}
_cwl-ica_icav2-deploy-pipeline_option_analysis_storage_id_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
if [[ -n "${ICAV2_ACCESS_TOKEN-}" ]]; then
  curl --silent --fail --location --request "GET" \
       --url "https://${ICAV2_BASE_URL-ica.illumina.com}/ica/rest/api/analysisStorages" \
       --header 'Accept: application/vnd.illumina.v3+json' \
       --header "Authorization: Bearer ${ICAV2_ACCESS_TOKEN}" | \
  jq --raw-output '.items[] | .id'
fi
 ) )
    compadd -X "analysis_storage_id:" $__dynamic_completion
}
_cwl-ica_icav2-deploy-pipeline_option_analysis_storage_size_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
if [[ -n "${ICAV2_ACCESS_TOKEN-}" ]]; then
  curl --silent --fail --location --request "GET" \
       --url "https://${ICAV2_BASE_URL-ica.illumina.com}/ica/rest/api/analysisStorages" \
       --header 'Accept: application/vnd.illumina.v3+json' \
       --header "Authorization: Bearer ${ICAV2_ACCESS_TOKEN}" | \
  jq --raw-output '.items[] | .name'
fi
 ) )
    compadd -X "analysis_storage_size:" $__dynamic_completion
}
_cwl-ica_icav2-get-analysis-step-logs_option_project_id_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
if [[ -n "${ICAV2_ACCESS_TOKEN-}" ]]; then
  curl --silent --fail --location --request "GET" \
       --url "https://${ICAV2_BASE_URL-ica.illumina.com}/ica/rest/api/projects" \
       --header 'Accept: application/vnd.illumina.v3+json' \
       --header "Authorization: Bearer ${ICAV2_ACCESS_TOKEN}" | \
  jq --raw-output '.items[] | .id'
fi
 ) )
    compadd -X "project_id:" $__dynamic_completion
}
_cwl-ica_icav2-get-analysis-step-logs_option_project_name_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
if [[ -n "${ICAV2_ACCESS_TOKEN-}" ]]; then
  curl --silent --fail --location --request "GET" \
       --url "https://${ICAV2_BASE_URL-ica.illumina.com}/ica/rest/api/projects" \
       --header 'Accept: application/vnd.illumina.v3+json' \
       --header "Authorization: Bearer ${ICAV2_ACCESS_TOKEN}" | \
  jq --raw-output '.items[] | .name'
fi
 ) )
    compadd -X "project_name:" $__dynamic_completion
}
_cwl-ica_icav2-launch-pipeline-analysis_option_launch_json_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
find "${CURRENT_WORD-.}"* -maxdepth 0 -type d & (
  if [[ -d "${CURRENT_WORD-.}" ]]; then
    find "${CURRENT_WORD-.}" -maxdepth 1 -type f -name '*.json';
  elif [[ -n "${CURRENT_WORD-}" && -d "$(dirname "${CURRENT_WORD}")" ]]; then
    find "$(dirname "${CURRENT_WORD}")" -maxdepth 1 -type f -name '*.json'
  else
    find "." -maxdepth 1 -type f -name '*.json'
  fi
) & wait
 ) )
    compadd -X "launch_json:" $__dynamic_completion
}
_cwl-ica_icav2-launch-pipeline-analysis_option_pipeline_id_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
if [[ -n "${ICAV2_ACCESS_TOKEN-}" ]]; then
  curl --silent --fail --location --request "GET" \
       --url "https://${ICAV2_BASE_URL-ica.illumina.com}/ica/rest/api/pipelines" \
       --header 'Accept: application/vnd.illumina.v3+json' \
       --header "Authorization: Bearer ${ICAV2_ACCESS_TOKEN}" | \
  jq --raw-output '.items[] | .id'
fi
 ) )
    compadd -X "pipeline_id:" $__dynamic_completion
}
_cwl-ica_icav2-launch-pipeline-analysis_option_pipeline_code_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
if [[ -n "${ICAV2_ACCESS_TOKEN-}" ]]; then
  curl --silent --fail --location --request "GET" \
       --url "https://${ICAV2_BASE_URL-ica.illumina.com}/ica/rest/api/pipelines" \
       --header 'Accept: application/vnd.illumina.v3+json' \
       --header "Authorization: Bearer ${ICAV2_ACCESS_TOKEN}" | \
  jq --raw-output '.items[] | .code'
fi
 ) )
    compadd -X "pipeline_code:" $__dynamic_completion
}
_cwl-ica_icav2-launch-pipeline-analysis_option_project_id_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
if [[ -n "${ICAV2_ACCESS_TOKEN-}" ]]; then
  curl --silent --fail --location --request "GET" \
       --url "https://${ICAV2_BASE_URL-ica.illumina.com}/ica/rest/api/projects" \
       --header 'Accept: application/vnd.illumina.v3+json' \
       --header "Authorization: Bearer ${ICAV2_ACCESS_TOKEN}" | \
  jq --raw-output '.items[] | .id'
fi
 ) )
    compadd -X "project_id:" $__dynamic_completion
}
_cwl-ica_icav2-launch-pipeline-analysis_option_project_name_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
if [[ -n "${ICAV2_ACCESS_TOKEN-}" ]]; then
  curl --silent --fail --location --request "GET" \
       --url "https://${ICAV2_BASE_URL-ica.illumina.com}/ica/rest/api/projects" \
       --header 'Accept: application/vnd.illumina.v3+json' \
       --header "Authorization: Bearer ${ICAV2_ACCESS_TOKEN}" | \
  jq --raw-output '.items[] | .name'
fi
 ) )
    compadd -X "project_name:" $__dynamic_completion
}
_cwl-ica_icav2-launch-pipeline-analysis_option_output_parent_folder_path_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
if [[ -n "${ICAV2_ACCESS_TOKEN-}" ]]; then
    project_index="-1";
    project_name="";
    project_id="";
    if [[ "$(basename "${SHELL}")" == "bash" ]]; then
        for i in "${!words[@]}"; do
           if [[ "${words[$i]}" == "--project-name" ]]; then
               project_index="$(expr $i + 1)";
               project_name="${words[$project_index]}";
           elif [[ "${words[$i]}" == "--project-id" ]]; then
               project_index="$(expr $i + 1)";
               project_id="${words[$project_index]}";
           fi;
        done;
    elif [[ "$(basename "${SHELL}")" == "zsh" ]]; then
        for ((i = 1; i <= $#words; i++)); do
           if [[ "${words[$i]}" == "--project-name" ]]; then
               project_index="$(expr $i + 1)";
               project_name="${words[$project_index]}";
           elif [[ "${words[$i]}" == "--project-id" ]]; then
               project_index="$(expr $i + 1)";
               project_id="${words[$project_index]}";
           fi;
        done;
    fi;
  if [[ -n "${project_name}" || -n "${project_id}" ]]; then
    if [[ -z "${project_id}" ]]; then
      project_id="$(curl --silent --fail --location \
                      --request "GET" \
                      --url "https://${ICAV2_BASE_URL-ica.illumina.com}/ica/rest/api/projects" \
                      --header "Accept: application/vnd.illumina.v3+json" \
                      --header "Authorization: Bearer ${ICAV2_ACCESS_TOKEN}" | \
                    jq --raw-output \
                      --arg "project_name" "${project_name}" \
                      '.items[] | select(.name==$project_name) | .id')";
    fi;
    if [[ "${CURRENT_WORD}" == */ ]]; then
      parent_folder="${CURRENT_WORD}";
    else
      parent_folder="$(dirname "${CURRENT_WORD}")";
    fi;
    curl --silent --fail --location \
      --request "GET" \
      --header "Accept: application/vnd.illumina.v3+json" \
      --header "Authorization: Bearer ${ICAV2_ACCESS_TOKEN}" \
      --url "https://${ICAV2_BASE_URL-ica.illumina.com}/ica/rest/api/projects/${project_id}/data?parentFolderPath=${parent_folder%/}/&filenameMatchMode=EXACT&type=FOLDER" |
    jq --raw-output \
      '.items[] | .data.details.path';
  fi
fi
 ) )
    compadd -X "output_parent_folder_path:" $__dynamic_completion
}
_cwl-ica_icav2-launch-pipeline-analysis_option_analysis_storage_id_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
if [[ -n "${ICAV2_ACCESS_TOKEN-}" ]]; then
  curl --silent --fail --location --request "GET" \
       --url "https://${ICAV2_BASE_URL-ica.illumina.com}/ica/rest/api/analysisStorages" \
       --header 'Accept: application/vnd.illumina.v3+json' \
       --header "Authorization: Bearer ${ICAV2_ACCESS_TOKEN}" | \
  jq --raw-output '.items[] | .id'
fi
 ) )
    compadd -X "analysis_storage_id:" $__dynamic_completion
}
_cwl-ica_icav2-launch-pipeline-analysis_option_analysis_storage_size_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
if [[ -n "${ICAV2_ACCESS_TOKEN-}" ]]; then
  curl --silent --fail --location --request "GET" \
       --url "https://${ICAV2_BASE_URL-ica.illumina.com}/ica/rest/api/analysisStorages" \
       --header 'Accept: application/vnd.illumina.v3+json' \
       --header "Authorization: Bearer ${ICAV2_ACCESS_TOKEN}" | \
  jq --raw-output '.items[] | .name'
fi
 ) )
    compadd -X "analysis_storage_size:" $__dynamic_completion
}
_cwl-ica_icav2-list-analysis-steps_option_project_id_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
if [[ -n "${ICAV2_ACCESS_TOKEN-}" ]]; then
  curl --silent --fail --location --request "GET" \
       --url "https://${ICAV2_BASE_URL-ica.illumina.com}/ica/rest/api/projects" \
       --header 'Accept: application/vnd.illumina.v3+json' \
       --header "Authorization: Bearer ${ICAV2_ACCESS_TOKEN}" | \
  jq --raw-output '.items[] | .id'
fi
 ) )
    compadd -X "project_id:" $__dynamic_completion
}
_cwl-ica_icav2-list-analysis-steps_option_project_name_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
if [[ -n "${ICAV2_ACCESS_TOKEN-}" ]]; then
  curl --silent --fail --location --request "GET" \
       --url "https://${ICAV2_BASE_URL-ica.illumina.com}/ica/rest/api/projects" \
       --header 'Accept: application/vnd.illumina.v3+json' \
       --header "Authorization: Bearer ${ICAV2_ACCESS_TOKEN}" | \
  jq --raw-output '.items[] | .name'
fi
 ) )
    compadd -X "project_name:" $__dynamic_completion
}
_cwl-ica_icav2-zip-workflow_option_workflow_path_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python3

"""
List the unregistered workflow paths
"""

# Externals
from pathlib import Path
from os import getcwd
from os.path import relpath

# CWL ICA
from cwl_ica.utils.repo import get_workflows_dir

# Get the current word value
if not "${CURRENT_WORD}" == "":
    current_word_value = "${CURRENT_WORD}"
else:
    current_word_value = None

# Resolve the current path
# If getcwd() is "/c/Users/awluc"
# 1. Non relative paths: current_word_value = "/etc" -> current_path_resolved = "/etc"
# 2. Relative parent path: current_word_value = "../../Program Files" -> current_path_resolved = "/c/Program Files"
# 3. Subfolder: current_word_value = "OneDrive" -> current_path_resolved = "/c/Users/awluc/OneDrive"
# 4. Subfolder of workflows dir = "OneDrive/GitHub/UMCCR/workflows/contig/" -> current path resolved
if current_word_value is not None:
    if current_word_value.endswith("/"):
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value)).resolve()
    else:
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value).parent).resolve()
else:
    current_word_value = ""
    current_path_resolved = Path(getcwd()).absolute()


# Is the current_path_resolved a subpath of the workflows directory?
try:
    _ = current_path_resolved.relative_to(get_workflows_dir())
    in_workflows_dir = True
except ValueError:
    in_workflows_dir = False

if not current_word_value == "" and in_workflows_dir:
    workflow_paths = [
        s_file.relative_to(get_workflows_dir())
        for s_file in current_path_resolved.glob("**/*.cwl")
    ]
else:
    workflow_paths = [
        s_file.relative_to(get_workflows_dir())
        for s_file in get_workflows_dir().glob("**/*.cwl")
    ]

if in_workflows_dir:
    current_path_resolved_relative_to_workflows_dir = current_path_resolved.relative_to(get_workflows_dir())
    if current_path_resolved_relative_to_workflows_dir == Path("."):
        for s_path in workflow_paths:
            if current_word_value.endswith("/"):
                print(Path(current_word_value) / s_path)
            else:
                print(Path(current_word_value).parent / s_path)
    else:
        for s_path in workflow_paths:
            if str(s_path).startswith(str(current_path_resolved_relative_to_workflows_dir)):
                if current_word_value.endswith("/"):
                    print(
                        Path(current_word_value) / s_path.relative_to(current_path_resolved_relative_to_workflows_dir))
                else:
                    print(Path(current_word_value).parent / s_path.relative_to(
                        current_path_resolved_relative_to_workflows_dir))

else:
    # Now get the workflows yaml path relative to the current path
    try:
        workflows_dir = get_workflows_dir().relative_to(current_path_resolved)
    except ValueError:
        # We could be in a different mount point OR just in a subdirectory
        if str(get_workflows_dir().absolute()) in str(relpath(get_workflows_dir(), current_path_resolved)):
            # Separate mount point
            workflows_dir = get_workflows_dir().absolute()
        else:
            workflows_dir = Path(relpath(get_workflows_dir(), current_path_resolved))

    # Now iterate through paths
    for s_path in workflow_paths:
        if current_word_value.endswith("/"):
            print(Path(current_word_value) / workflows_dir.joinpath(s_path))
        else:
            print(Path(current_word_value).parent / workflows_dir.joinpath(s_path))
EOF

 ) )
    compadd -X "workflow_path:" $__dynamic_completion
}
_cwl-ica_list-projects_option_tenant_name_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

# CWL ICA imports
from cwl_ica.utils.repo import get_tenant_yaml_path
from cwl_ica.utils.miscell import read_yaml

for tenant in read_yaml(get_tenant_yaml_path())["tenants"]:
    print(tenant["tenant_name"])
EOF

 ) )
    compadd -X "tenant_name:" $__dynamic_completion
}
_cwl-ica_list-tool-runs_option_tool_path_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python3

"""
List the registered tool paths
"""

# External imports
from pathlib import Path
from os import getcwd
from os.path import relpath

# CWL ICA
from cwl_ica.utils.repo import get_tool_yaml_path
from cwl_ica.utils.repo import get_tools_dir
from cwl_ica.utils.miscell import read_yaml

tool_paths = [
    Path(tool["path"]) / Path(version["path"])
    for tool in read_yaml(get_tool_yaml_path())["tools"]
    for version in tool["versions"]
]

# Get the current word value
if not "${CURRENT_WORD}" == "":
    current_word_value = "${CURRENT_WORD}"
else:
    current_word_value = None

# Resolve the current path
# If getcwd() is "/c/Users/awluc"
# 1. Non relative paths: current_word_value = "/etc" -> current_path_resolved = "/etc"
# 2. Relative parent path: current_word_value = "../../Program Files" -> current_path_resolved = "/c/Program Files"
# 3. Subfolder: current_word_value = "OneDrive" -> current_path_resolved = "/c/Users/awluc/OneDrive"
# 4. Subfolder of tools dir = "OneDrive/GitHub/UMCCR/tools/contig/" -> current path resolved
if current_word_value is not None:
    if current_word_value.endswith("/"):
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value)).resolve()
    else:
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value).parent).resolve()

else:
    current_word_value = ""
    current_path_resolved = Path(getcwd()).absolute()

# Is the current_path_resolved a subpath of the tools directory?
try:
    _ = current_path_resolved.relative_to(get_tools_dir())
    in_tools_dir = True
except ValueError:
    in_tools_dir = False

if in_tools_dir:
    current_path_resolved_relative_to_tools_dir = current_path_resolved.relative_to(get_tools_dir())
    if current_path_resolved_relative_to_tools_dir == Path("."):
        for s_path in tool_paths:
            if current_word_value.endswith("/"):
                print(Path(current_word_value) / s_path)
            else:
                print(Path(current_word_value).parent / s_path)
    else:
        for s_path in tool_paths:
            if str(s_path).startswith(str(current_path_resolved_relative_to_tools_dir)):
                if current_word_value.endswith("/"):
                    print(Path(current_word_value) / s_path.relative_to(current_path_resolved_relative_to_tools_dir))
                else:
                    print(Path(current_word_value).parent / s_path.relative_to(
                        current_path_resolved_relative_to_tools_dir))

else:
    # Now get the tools yaml path relative to the current path
    try:
        tools_dir = get_tools_dir().relative_to(current_path_resolved)
    except ValueError:
        # We could be in a different mount point OR just in a subdirectory
        if str(get_tools_dir().absolute()) in str(relpath(get_tools_dir(), current_path_resolved)):
            # Separate mount point
            tools_dir = get_tools_dir().absolute()
        else:
            tools_dir = Path(relpath(get_tools_dir(), current_path_resolved))

    # Now iterate through paths
    for s_path in tool_paths:
        if current_word_value.endswith("/"):
            print(Path(current_word_value) / tools_dir.joinpath(s_path))
        else:
            print(Path(current_word_value).parent / tools_dir.joinpath(s_path))
EOF

 ) )
    compadd -X "tool_path:" $__dynamic_completion
}
_cwl-ica_list-tool-runs_option_project_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the project names in the project.yaml file
"""
from cwl_ica.utils.repo import get_project_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each project name
for project in read_yaml(get_project_yaml_path())["projects"]:
    print(project["project_name"])
EOF

 ) )
    compadd -X "project:" $__dynamic_completion
}
_cwl-ica_list-workflow-runs_option_workflow_path_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
__cwl-ica_list_registered_workflows.py
EOF

 ) )
    compadd -X "workflow_path:" $__dynamic_completion
}
_cwl-ica_list-workflow-runs_option_project_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the project names in the project.yaml file
"""
from cwl_ica.utils.repo import get_project_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each project name
for project in read_yaml(get_project_yaml_path())["projects"]:
    print(project["project_name"])
EOF

 ) )
    compadd -X "project:" $__dynamic_completion
}
_cwl-ica_project-init_option_tenant_name_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

# CWL ICA imports
from cwl_ica.utils.repo import get_tenant_yaml_path
from cwl_ica.utils.miscell import read_yaml

for tenant in read_yaml(get_tenant_yaml_path())["tenants"]:
    print(tenant["tenant_name"])
EOF
 ) )
    compadd -X "tenant_name:" $__dynamic_completion
}
_cwl-ica_register-tool-run-instance_option_project_name_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the project names in the project.yaml file
"""
from cwl_ica.utils.repo import get_project_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each project name
for project in read_yaml(get_project_yaml_path())["projects"]:
    print(project["project_name"])
EOF

 ) )
    compadd -X "project_name:" $__dynamic_completion
}
_cwl-ica_register-workflow-run-instance_option_project_name_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the project names in the project.yaml file
"""
from cwl_ica.utils.repo import get_project_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each project name
for project in read_yaml(get_project_yaml_path())["projects"]:
    print(project["project_name"])
EOF

 ) )
    compadd -X "project_name:" $__dynamic_completion
}
_cwl-ica_schema-init_option_schema_path_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python3

"""
List the unregistered schema paths
"""

# External imports
from pathlib import Path
from os import getcwd
from os.path import relpath

# CWL ICA imports
from cwl_ica.utils.repo import get_schema_yaml_path
from cwl_ica.utils.repo import get_schemas_dir
from cwl_ica.utils.miscell import read_yaml


registered_schema_paths = [
    Path(schema["path"]) / Path(version["path"])
    for schema in read_yaml(get_schema_yaml_path())["schemas"]
    for version in schema["versions"]
]

# Get the current word value
if not "${CURRENT_WORD}" == "":
    current_word_value = "${CURRENT_WORD}"
else:
    current_word_value = None

# Resolve the current path
# If getcwd() is "/c/Users/awluc"
# 1. Non relative paths: current_word_value = "/etc" -> current_path_resolved = "/etc"
# 2. Relative parent path: current_word_value = "../../Program Files" -> current_path_resolved = "/c/Program Files"
# 3. Subfolder: current_word_value = "OneDrive" -> current_path_resolved = "/c/Users/awluc/OneDrive"
# 4. Subfolder of schemas dir = "OneDrive/GitHub/UMCCR/schemas/contig/" -> current path resolved
if current_word_value is not None:
    if current_word_value.endswith("/"):
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value)).resolve()
    else:
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value).parent).resolve()
else:
    current_word_value = ""
    current_path_resolved = Path(getcwd()).absolute()


# Is the current_path_resolved a subpath of the schemas directory?
try:
    _ = current_path_resolved.relative_to(get_schemas_dir())
    in_schemas_dir = True
except ValueError:
    in_schemas_dir = False

if not current_word_value == "" and in_schemas_dir:
    all_paths = [
        s_file.relative_to(get_schemas_dir())
        for s_file in current_path_resolved.glob("**/*.yaml")]
else:
    all_paths = [
        s_file.relative_to(get_schemas_dir())
        for s_file in get_schemas_dir().glob("**/*.yaml")
    ]

schema_paths = [
    a_path
    for a_path in all_paths
    if a_path not in registered_schema_paths
]

if in_schemas_dir:
    current_path_resolved_relative_to_schemas_dir = current_path_resolved.relative_to(get_schemas_dir())
    if current_path_resolved_relative_to_schemas_dir == Path("."):
        for s_path in schema_paths:
            if current_word_value.endswith("/"):
                print(Path(current_word_value) / s_path)
            else:
                print(Path(current_word_value).parent / s_path)
    else:
        for s_path in schema_paths:
            if str(s_path).startswith(str(current_path_resolved_relative_to_schemas_dir)):
                if current_word_value.endswith("/"):
                    print(Path(current_word_value) / s_path.relative_to(current_path_resolved_relative_to_schemas_dir))
                else:
                    print(Path(current_word_value).parent / s_path.relative_to(current_path_resolved_relative_to_schemas_dir))

else:
    # Now get the schemas yaml path relative to the current path
    try:
        schemas_dir = get_schemas_dir().relative_to(current_path_resolved)
    except ValueError:
        # We could be in a different mount point OR just in a subdirectory
        if str(get_schemas_dir().absolute()) in str(relpath(get_schemas_dir(), current_path_resolved)):
            # Separate mount point
            schemas_dir = get_schemas_dir().absolute()
        else:
            schemas_dir = Path(relpath(get_schemas_dir(), current_path_resolved))

    # Now iterate through paths
    for s_path in schema_paths:
        if current_word_value.endswith("/"):
            print(Path(current_word_value) / schemas_dir.joinpath(s_path))
        else:
            print(Path(current_word_value).parent / schemas_dir.joinpath(s_path))
EOF

 ) )
    compadd -X "schema_path:" $__dynamic_completion
}
_cwl-ica_schema-sync_option_schema_path_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python3

"""
List the registered schema paths
"""

# Externals
from pathlib import Path
from os import getcwd
from os.path import relpath

# CWL ICA
from cwl_ica.utils.repo import read_yaml, get_schema_yaml_path, get_schemas_dir

schema_paths = [
    Path(schema["path"]) / Path(version["path"])
    for schema in read_yaml(get_schema_yaml_path())["schemas"]
    for version in schema["versions"]
]

# Get the current word value
if not "${CURRENT_WORD}" == "":
    current_word_value = "${CURRENT_WORD}"
else:
    current_word_value = None

# Resolve the current path
# If getcwd() is "/c/Users/awluc"
# 1. Non relative paths: current_word_value = "/etc" -> current_path_resolved = "/etc"
# 2. Relative parent path: current_word_value = "../../Program Files" -> current_path_resolved = "/c/Program Files"
# 3. Subfolder: current_word_value = "OneDrive" -> current_path_resolved = "/c/Users/awluc/OneDrive"
# 4. Subfolder of schemas dir = "OneDrive/GitHub/UMCCR/schemas/contig/" -> current path resolved
if current_word_value is not None:
    if current_word_value.endswith("/"):
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value)).resolve()
    else:
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value).parent).resolve()
else:
    current_word_value = ""
    current_path_resolved = Path(getcwd()).absolute()

# Is the current_path_resolved a subpath of the schemas directory?
try:
    _ = current_path_resolved.relative_to(get_schemas_dir())
    in_schemas_dir = True
except ValueError:
    in_schemas_dir = False

if in_schemas_dir:
    current_path_resolved_relative_to_schemas_dir = current_path_resolved.relative_to(get_schemas_dir())
    if current_path_resolved_relative_to_schemas_dir == Path("."):
        for s_path in schema_paths:
            if current_word_value.endswith("/"):
                print(Path(current_word_value) / s_path)
            else:
                print(Path(current_word_value).parent / s_path)
    else:
        for s_path in schema_paths:
            if str(s_path).startswith(str(current_path_resolved_relative_to_schemas_dir)):
                if current_word_value.endswith("/"):
                    print(Path(current_word_value) / s_path.relative_to(current_path_resolved_relative_to_schemas_dir))
                else:
                    print(Path(current_word_value).parent / s_path.relative_to(current_path_resolved_relative_to_schemas_dir))

else:
    # Now get the schemas yaml path relative to the current path
    try:
        schemas_dir = get_schemas_dir().relative_to(current_path_resolved)
    except ValueError:
        # We could be in a different mount point OR just in a subdirectory
        if str(get_schemas_dir().absolute()) in str(relpath(get_schemas_dir(), current_path_resolved)):
            # Separate mount point
            schemas_dir = get_schemas_dir().absolute()
        else:
            schemas_dir = Path(relpath(get_schemas_dir(), current_path_resolved))

    # Now iterate through paths
    for s_path in schema_paths:
        if current_word_value.endswith("/"):
            print(Path(current_word_value) / schemas_dir.joinpath(s_path))
        else:
            print(Path(current_word_value).parent / schemas_dir.joinpath(s_path))
EOF

 ) )
    compadd -X "schema_path:" $__dynamic_completion
}
_cwl-ica_schema-validate_option_schema_path_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python3

"""
List the unregistered schema paths
"""

# Externals
from pathlib import Path
from os import getcwd
from os.path import relpath

# CWL ICA
from cwl_ica.utils.repo import get_schemas_dir

# Get the current word value
if not "${CURRENT_WORD-}" == "":
    current_word_value = "${CURRENT_WORD}"
else:
    current_word_value = None

# Resolve the current path
# If getcwd() is "/c/Users/awluc"
# 1. Non relative paths: current_word_value = "/etc" -> current_path_resolved = "/etc"
# 2. Relative parent path: current_word_value = "../../Program Files" -> current_path_resolved = "/c/Program Files"
# 3. Subfolder: current_word_value = "OneDrive" -> current_path_resolved = "/c/Users/awluc/OneDrive"
# 4. Subfolder of schemas dir = "OneDrive/GitHub/UMCCR/schemas/contig/" -> current path resolved
if current_word_value is not None:
    if current_word_value.endswith("/"):
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value)).resolve()
    else:
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value).parent).resolve()
else:
    current_word_value = ""
    current_path_resolved = Path(getcwd()).absolute()

# Is the current_path_resolved a subpath of the schemas directory?
try:
    _ = current_path_resolved.relative_to(get_schemas_dir())
    in_schemas_dir = True
except ValueError:
    in_schemas_dir = False

if not current_word_value == "" and in_schemas_dir:
    schema_paths = [
        s_file.relative_to(get_schemas_dir())
        for s_file in current_path_resolved.glob("**/*.yaml")
    ]
else:
    schema_paths = [
        s_file.relative_to(get_schemas_dir())
        for s_file in get_schemas_dir().glob("**/*.yaml")
    ]

if in_schemas_dir:
    current_path_resolved_relative_to_schemas_dir = current_path_resolved.relative_to(get_schemas_dir())
    if current_path_resolved_relative_to_schemas_dir == Path("."):
        for s_path in schema_paths:
            if current_word_value.endswith("/"):
                print(Path(current_word_value) / s_path)
            else:
                print(Path(current_word_value).parent / s_path)
    else:
        for s_path in schema_paths:
            if str(s_path).startswith(str(current_path_resolved_relative_to_schemas_dir)):
                if current_word_value.endswith("/"):
                    print(Path(current_word_value) / s_path.relative_to(
                        current_path_resolved_relative_to_schemas_dir))
                else:
                    print(Path(current_word_value).parent / s_path.relative_to(
                        current_path_resolved_relative_to_schemas_dir))

else:
    # Now get the schemas yaml path relative to the current path
    try:
        schemas_dir = get_schemas_dir().relative_to(current_path_resolved)
    except ValueError:
        # We could be in a different mount point OR just in a subdirectory
        if str(get_schemas_dir().absolute()) in str(relpath(get_schemas_dir(), current_path_resolved)):
            # Separate mount point
            schemas_dir = get_schemas_dir().absolute()
        else:
            schemas_dir = Path(relpath(get_schemas_dir(), current_path_resolved))

    # Now iterate through paths
    for s_path in schema_paths:
        if current_word_value.endswith("/"):
            print(Path(current_word_value) / schemas_dir.joinpath(s_path))
        else:
            print(Path(current_word_value).parent / schemas_dir.joinpath(s_path))
EOF

 ) )
    compadd -X "schema_path:" $__dynamic_completion
}
_cwl-ica_set-default-project_option_project_name_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the project names in the project.yaml file
"""
from cwl_ica.utils.repo import get_project_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each project name
for project in read_yaml(get_project_yaml_path())["projects"]:
    print(project["project_name"])
EOF

 ) )
    compadd -X "project_name:" $__dynamic_completion
}
_cwl-ica_set-default-tenant_option_tenant_name_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

# CWL ICA imports
from cwl_ica.utils.repo import get_tenant_yaml_path
from cwl_ica.utils.miscell import read_yaml

for tenant in read_yaml(get_tenant_yaml_path())["tenants"]:
    print(tenant["tenant_name"])
EOF

 ) )
    compadd -X "tenant_name:" $__dynamic_completion
}
_cwl-ica_set-default-user_option_username_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the category names in the categories.yaml file
"""
# CWL ICA imports
from cwl_ica.utils.repo import get_user_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each project name
for user in read_yaml(get_user_yaml_path())["users"]:
    print(user["username"])
EOF

 ) )
    compadd -X "username:" $__dynamic_completion
}
_cwl-ica_tool-init_option_tool_path_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python3

"""
List the unregistered tool paths
"""

# External imports
from pathlib import Path
from os import getcwd
from os.path import relpath

# CWL ICA imports
from cwl_ica.utils.repo import get_tool_yaml_path
from cwl_ica.utils.repo import get_tools_dir
from cwl_ica.utils.miscell import read_yaml


registered_tool_paths = [
    Path(tool["path"]) / Path(version["path"])
    for tool in read_yaml(get_tool_yaml_path())["tools"]
    for version in tool["versions"]
]

# Get the current word value
if not "${CURRENT_WORD}" == "":
    current_word_value = "${CURRENT_WORD}"
else:
    current_word_value = None

# Resolve the current path
# If getcwd() is "/c/Users/awluc"
# 1. Non relative paths: current_word_value = "/etc" -> current_path_resolved = "/etc"
# 2. Relative parent path: current_word_value = "../../Program Files" -> current_path_resolved = "/c/Program Files"
# 3. Subfolder: current_word_value = "OneDrive" -> current_path_resolved = "/c/Users/awluc/OneDrive"
# 4. Subfolder of tools dir = "OneDrive/GitHub/UMCCR/tools/contig/" -> current path resolved
if current_word_value is not None:
    if current_word_value.endswith("/"):
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value)).resolve()
    else:
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value).parent).resolve()
else:
    current_word_value = ""
    current_path_resolved = Path(getcwd()).absolute()

# Is the current_path_resolved a subpath of the tools directory?
try:
    _ = current_path_resolved.relative_to(get_tools_dir())
    in_tools_dir = True
except ValueError:
    in_tools_dir = False

if not current_word_value == "" and in_tools_dir:
    all_paths = [
        s_file.relative_to(get_tools_dir())
        for s_file in current_path_resolved.glob("**/*.cwl")
    ]
else:
    all_paths = [
        s_file.relative_to(get_tools_dir())
        for s_file in get_tools_dir().glob("**/*.cwl")
    ]

tool_paths = [
    a_path
    for a_path in all_paths
    if a_path not in registered_tool_paths
]

if in_tools_dir:
    current_path_resolved_relative_to_tools_dir = current_path_resolved.relative_to(get_tools_dir())
    if current_path_resolved_relative_to_tools_dir == Path("."):
        for s_path in tool_paths:
            if current_word_value.endswith("/"):
                print(Path(current_word_value) / s_path)
            else:
                print(Path(current_word_value).parent / s_path)
    else:
        for s_path in tool_paths:
            if str(s_path).startswith(str(current_path_resolved_relative_to_tools_dir)):
                if current_word_value.endswith("/"):
                    print(Path(current_word_value) / s_path.relative_to(current_path_resolved_relative_to_tools_dir))
                else:
                    print(Path(current_word_value).parent / s_path.relative_to(
                        current_path_resolved_relative_to_tools_dir))

else:
    # Now get the tools yaml path relative to the current path
    try:
        tools_dir = get_tools_dir().relative_to(current_path_resolved)
    except ValueError:
        # We could be in a different mount point OR just in a subdirectory
        if str(get_tools_dir().absolute()) in str(relpath(get_tools_dir(), current_path_resolved)):
            # Separate mount point
            tools_dir = get_tools_dir().absolute()
        else:
            tools_dir = Path(relpath(get_tools_dir(), current_path_resolved))

    # Now iterate through paths
    for s_path in tool_paths:
        if current_word_value.endswith("/"):
            print(Path(current_word_value) / tools_dir.joinpath(s_path))
        else:
            print(Path(current_word_value).parent / tools_dir.joinpath(s_path))
EOF
 ) )
    compadd -X "tool_path:" $__dynamic_completion
}
_cwl-ica_tool-init_option_projects_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the project names in the project.yaml file
"""
from cwl_ica.utils.repo import get_project_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each project name
for project in read_yaml(get_project_yaml_path())["projects"]:
    print(project["project_name"])
EOF

 ) )
    compadd -X "projects:" $__dynamic_completion
}
_cwl-ica_tool-init_option_tenants_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

# CWL ICA imports
from cwl_ica.utils.repo import get_tenant_yaml_path
from cwl_ica.utils.miscell import read_yaml

for tenant in read_yaml(get_tenant_yaml_path())["tenants"]:
    print(tenant["tenant_name"])
EOF

 ) )
    compadd -X "tenants:" $__dynamic_completion
}
_cwl-ica_tool-init_option_categories_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the category names in the categories.yaml file
"""
from cwl_ica.utils.repo import get_category_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each project name
for category in read_yaml(get_category_yaml_path())["categories"]:
    print(category["name"])
EOF

 ) )
    compadd -X "categories:" $__dynamic_completion
}
_cwl-ica_tool-sync_option_tool_path_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python3

"""
List the registered tool paths
"""

# External imports
from pathlib import Path
from os import getcwd
from os.path import relpath

# CWL ICA
from cwl_ica.utils.repo import get_tool_yaml_path
from cwl_ica.utils.repo import get_tools_dir
from cwl_ica.utils.miscell import read_yaml

tool_paths = [
    Path(tool["path"]) / Path(version["path"])
    for tool in read_yaml(get_tool_yaml_path())["tools"]
    for version in tool["versions"]
]

# Get the current word value
if not "${CURRENT_WORD}" == "":
    current_word_value = "${CURRENT_WORD}"
else:
    current_word_value = None

# Resolve the current path
# If getcwd() is "/c/Users/awluc"
# 1. Non relative paths: current_word_value = "/etc" -> current_path_resolved = "/etc"
# 2. Relative parent path: current_word_value = "../../Program Files" -> current_path_resolved = "/c/Program Files"
# 3. Subfolder: current_word_value = "OneDrive" -> current_path_resolved = "/c/Users/awluc/OneDrive"
# 4. Subfolder of tools dir = "OneDrive/GitHub/UMCCR/tools/contig/" -> current path resolved
if current_word_value is not None:
    if current_word_value.endswith("/"):
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value)).resolve()
    else:
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value).parent).resolve()

else:
    current_word_value = ""
    current_path_resolved = Path(getcwd()).absolute()

# Is the current_path_resolved a subpath of the tools directory?
try:
    _ = current_path_resolved.relative_to(get_tools_dir())
    in_tools_dir = True
except ValueError:
    in_tools_dir = False

if in_tools_dir:
    current_path_resolved_relative_to_tools_dir = current_path_resolved.relative_to(get_tools_dir())
    if current_path_resolved_relative_to_tools_dir == Path("."):
        for s_path in tool_paths:
            if current_word_value.endswith("/"):
                print(Path(current_word_value) / s_path)
            else:
                print(Path(current_word_value).parent / s_path)
    else:
        for s_path in tool_paths:
            if str(s_path).startswith(str(current_path_resolved_relative_to_tools_dir)):
                if current_word_value.endswith("/"):
                    print(Path(current_word_value) / s_path.relative_to(current_path_resolved_relative_to_tools_dir))
                else:
                    print(Path(current_word_value).parent / s_path.relative_to(
                        current_path_resolved_relative_to_tools_dir))

else:
    # Now get the tools yaml path relative to the current path
    try:
        tools_dir = get_tools_dir().relative_to(current_path_resolved)
    except ValueError:
        # We could be in a different mount point OR just in a subdirectory
        if str(get_tools_dir().absolute()) in str(relpath(get_tools_dir(), current_path_resolved)):
            # Separate mount point
            tools_dir = get_tools_dir().absolute()
        else:
            tools_dir = Path(relpath(get_tools_dir(), current_path_resolved))

    # Now iterate through paths
    for s_path in tool_paths:
        if current_word_value.endswith("/"):
            print(Path(current_word_value) / tools_dir.joinpath(s_path))
        else:
            print(Path(current_word_value).parent / tools_dir.joinpath(s_path))
EOF

 ) )
    compadd -X "tool_path:" $__dynamic_completion
}
_cwl-ica_tool-sync_option_projects_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the project names in the project.yaml file
"""
from cwl_ica.utils.repo import get_project_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each project name
for project in read_yaml(get_project_yaml_path())["projects"]:
    print(project["project_name"])
EOF

 ) )
    compadd -X "projects:" $__dynamic_completion
}
_cwl-ica_tool-sync_option_tenants_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

# CWL ICA imports
from cwl_ica.utils.repo import get_tenant_yaml_path
from cwl_ica.utils.miscell import read_yaml

for tenant in read_yaml(get_tenant_yaml_path())["tenants"]:
    print(tenant["tenant_name"])
EOF

 ) )
    compadd -X "tenants:" $__dynamic_completion
}
_cwl-ica_tool-validate_option_tool_path_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python3

"""
List the unregistered tool paths
"""

# Externals
from pathlib import Path
from os import getcwd
from os.path import relpath

# CWL ICA
from cwl_ica.utils.repo import get_tools_dir

# Get the current word value
if not "${CURRENT_WORD}" == "":
    current_word_value = "${CURRENT_WORD}"
else:
    current_word_value = None

# Resolve the current path
# If getcwd() is "/c/Users/awluc"
# 1. Non relative paths: current_word_value = "/etc" -> current_path_resolved = "/etc"
# 2. Relative parent path: current_word_value = "../../Program Files" -> current_path_resolved = "/c/Program Files"
# 3. Subfolder: current_word_value = "OneDrive" -> current_path_resolved = "/c/Users/awluc/OneDrive"
# 4. Subfolder of tools dir = "OneDrive/GitHub/UMCCR/tools/contig/" -> current path resolved
if current_word_value is not None:
    if current_word_value.endswith("/"):
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value)).resolve()
    else:
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value).parent).resolve()
else:
    current_word_value = ""
    current_path_resolved = Path(getcwd()).absolute()


# Is the current_path_resolved a subpath of the tools directory?
try:
    _ = current_path_resolved.relative_to(get_tools_dir())
    in_tools_dir = True
except ValueError:
    in_tools_dir = False

if not current_word_value == "" and in_tools_dir:
    tool_paths = [
        s_file.relative_to(get_tools_dir())
        for s_file in current_path_resolved.glob("**/*.cwl")
    ]
else:
    tool_paths = [
        s_file.relative_to(get_tools_dir())
        for s_file in get_tools_dir().glob("**/*.cwl")
    ]

if in_tools_dir:
    current_path_resolved_relative_to_tools_dir = current_path_resolved.relative_to(get_tools_dir())
    if current_path_resolved_relative_to_tools_dir == Path("."):
        for s_path in tool_paths:
            if current_word_value.endswith("/"):
                print(Path(current_word_value) / s_path)
            else:
                print(Path(current_word_value).parent / s_path)
    else:
        for s_path in tool_paths:
            if str(s_path).startswith(str(current_path_resolved_relative_to_tools_dir)):
                if current_word_value.endswith("/"):
                    print(Path(current_word_value) / s_path.relative_to(current_path_resolved_relative_to_tools_dir))
                else:
                    print(Path(current_word_value).parent / s_path.relative_to(
                        current_path_resolved_relative_to_tools_dir))

else:
    # Now get the tools yaml path relative to the current path
    try:
        tools_dir = get_tools_dir().relative_to(current_path_resolved)
    except ValueError:
        # We could be in a different mount point OR just in a subdirectory
        if str(get_tools_dir().absolute()) in str(relpath(get_tools_dir(), current_path_resolved)):
            # Separate mount point
            tools_dir = get_tools_dir().absolute()
        else:
            tools_dir = Path(relpath(get_tools_dir(), current_path_resolved))

    # Now iterate through paths
    for s_path in tool_paths:
        if current_word_value.endswith("/"):
            print(Path(current_word_value) / tools_dir.joinpath(s_path))
        else:
            print(Path(current_word_value).parent / tools_dir.joinpath(s_path))
EOF

 ) )
    compadd -X "tool_path:" $__dynamic_completion
}
_cwl-ica_typescript-expression-update_option_typescript_expression_dir_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python3

"""
List all the typescript expression paths
"""

# Externals
from pathlib import Path
from os import getcwd
from os.path import relpath

# CWL ICA
from cwl_ica.utils.repo import get_cwl_ica_repo_path

# Get the current word value
if not "${CURRENT_WORD}" == "":
    current_word_value = "${CURRENT_WORD}"
else:
    current_word_value = None

if current_word_value is None:
    current_word_value = ""
    current_path_resolved = Path(getcwd()).absolute()
    typescript_expression_paths = [
        s_file.parent.relative_to(get_cwl_ica_repo_path())
        for s_file in get_cwl_ica_repo_path().glob("**/*.ts")
        # We don't want to pull in the typescript test files
        if not (len(s_file.parent.parts) >= 1 and s_file.parent.parts[-1] == 'tests') and
        # We also want to make sure it's under the tools, expressions or typescript-expressions directories
        len(
            {"tools", "expressions", "typescript-expressions"}.intersection(
                [
                    s_file.resolve().absolute().relative_to(get_cwl_ica_repo_path()).parent.parts[0]
                ]
            )
        ) > 0
    ]
else:
    if current_word_value.endswith("/"):
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value)).resolve()
    else:
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value).parent).resolve()

    typescript_expression_paths = [
        s_file.parent.relative_to(get_cwl_ica_repo_path())
        for s_file in current_path_resolved.glob("**/*.ts")
        # We don't want to pull in the typescript test files
        if not (len(s_file.parent.parts) >= 1 and s_file.parent.parts[-1] == 'tests') and
           # We also want to make sure it's under the tools, expressions or typescript-expressions directories
           len(
               {"tools", "expressions", "typescript-expressions"}.intersection(
                   [
                       s_file.resolve().absolute().relative_to(get_cwl_ica_repo_path()).parent.parts[0]
                   ]
               )
           ) > 0
    ]

# Resolve the current path
# If getcwd() is "/c/Users/awluc"
# 1. Non relative paths: current_word_value = "/etc" -> current_path_resolved = "/etc"
# 2. Relative parent path: current_word_value = "../../Program Files" -> current_path_resolved = "/c/Program Files"
# 3. Subfolder: current_word_value = "OneDrive" -> current_path_resolved = "/c/Users/awluc/OneDrive"
# 4. Subfolder of expressions dir = "OneDrive/GitHub/UMCCR/expressions/contig/" -> current path resolved

# Is the current_path_resolved a subpath of the expressions directory?
try:
    _ = current_path_resolved.relative_to(get_cwl_ica_repo_path())
    in_repo_dir = True
except ValueError:
    in_repo_dir = False

if in_repo_dir:
    current_path_resolved_relative_to_expressions_dir = current_path_resolved.relative_to(get_cwl_ica_repo_path())
    if current_path_resolved_relative_to_expressions_dir == Path("."):
        for s_path in typescript_expression_paths:
            if current_word_value.endswith("/"):
                print(Path(current_word_value) / s_path)
            else:
                print(Path(current_word_value).parent / s_path)
    else:
        for s_path in typescript_expression_paths:
            if str(s_path).startswith(str(current_path_resolved_relative_to_expressions_dir)):
                if current_word_value.endswith("/"):
                    print(Path(current_word_value) / s_path.relative_to(
                        current_path_resolved_relative_to_expressions_dir))
                else:
                    print(Path(current_word_value).parent / s_path.relative_to(
                        current_path_resolved_relative_to_expressions_dir))

else:
    # Now get the expressions yaml path relative to the current path
    try:
        expressions_dir = get_cwl_ica_repo_path().relative_to(current_path_resolved)
    except ValueError:
        # We could be in a different mount point OR just in a subdirectory
        if str(get_cwl_ica_repo_path().absolute()) in str(relpath(get_cwl_ica_repo_path(), current_path_resolved)):
            # Separate mount point
            expressions_dir = get_cwl_ica_repo_path().absolute()
        else:
            expressions_dir = Path(relpath(get_cwl_ica_repo_path(), current_path_resolved))

    # Now iterate through paths
    for s_path in typescript_expression_paths:
        if current_word_value.endswith("/"):
            print(Path(current_word_value) / expressions_dir.joinpath(s_path))
        else:
            print(Path(current_word_value).parent / expressions_dir.joinpath(s_path))
EOF

 ) )
    compadd -X "typescript_expression_dir:" $__dynamic_completion
}
_cwl-ica_typescript-expression-validate_option_typescript_expression_dir_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python3

"""
List all the typescript expression paths
"""

# Externals
from pathlib import Path
from os import getcwd
from os.path import relpath

# CWL ICA
from cwl_ica.utils.repo import get_cwl_ica_repo_path

# Get the current word value
if not "${CURRENT_WORD}" == "":
    current_word_value = "${CURRENT_WORD}"
else:
    current_word_value = None

if current_word_value is None:
    current_word_value = ""
    current_path_resolved = Path(getcwd()).absolute()
    typescript_expression_paths = [
        s_file.parent.relative_to(get_cwl_ica_repo_path())
        for s_file in get_cwl_ica_repo_path().glob("**/*.ts")
        # We don't want to pull in the typescript test files
        if not (len(s_file.parent.parts) >= 1 and s_file.parent.parts[-1] == 'tests') and
        # We also want to make sure it's under the tools, expressions or typescript-expressions directories
        len(
            {"tools", "expressions", "typescript-expressions"}.intersection(
                [
                    s_file.resolve().absolute().relative_to(get_cwl_ica_repo_path()).parent.parts[0]
                ]
            )
        ) > 0
    ]
else:
    if current_word_value.endswith("/"):
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value)).resolve()
    else:
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value).parent).resolve()

    typescript_expression_paths = [
        s_file.parent.relative_to(get_cwl_ica_repo_path())
        for s_file in current_path_resolved.glob("**/*.ts")
        # We don't want to pull in the typescript test files
        if not (len(s_file.parent.parts) >= 1 and s_file.parent.parts[-1] == 'tests') and
           # We also want to make sure it's under the tools, expressions or typescript-expressions directories
           len(
               {"tools", "expressions", "typescript-expressions"}.intersection(
                   [
                       s_file.resolve().absolute().relative_to(get_cwl_ica_repo_path()).parent.parts[0]
                   ]
               )
           ) > 0
    ]

# Resolve the current path
# If getcwd() is "/c/Users/awluc"
# 1. Non relative paths: current_word_value = "/etc" -> current_path_resolved = "/etc"
# 2. Relative parent path: current_word_value = "../../Program Files" -> current_path_resolved = "/c/Program Files"
# 3. Subfolder: current_word_value = "OneDrive" -> current_path_resolved = "/c/Users/awluc/OneDrive"
# 4. Subfolder of expressions dir = "OneDrive/GitHub/UMCCR/expressions/contig/" -> current path resolved

# Is the current_path_resolved a subpath of the expressions directory?
try:
    _ = current_path_resolved.relative_to(get_cwl_ica_repo_path())
    in_repo_dir = True
except ValueError:
    in_repo_dir = False

if in_repo_dir:
    current_path_resolved_relative_to_expressions_dir = current_path_resolved.relative_to(get_cwl_ica_repo_path())
    if current_path_resolved_relative_to_expressions_dir == Path("."):
        for s_path in typescript_expression_paths:
            if current_word_value.endswith("/"):
                print(Path(current_word_value) / s_path)
            else:
                print(Path(current_word_value).parent / s_path)
    else:
        for s_path in typescript_expression_paths:
            if str(s_path).startswith(str(current_path_resolved_relative_to_expressions_dir)):
                if current_word_value.endswith("/"):
                    print(Path(current_word_value) / s_path.relative_to(
                        current_path_resolved_relative_to_expressions_dir))
                else:
                    print(Path(current_word_value).parent / s_path.relative_to(
                        current_path_resolved_relative_to_expressions_dir))

else:
    # Now get the expressions yaml path relative to the current path
    try:
        expressions_dir = get_cwl_ica_repo_path().relative_to(current_path_resolved)
    except ValueError:
        # We could be in a different mount point OR just in a subdirectory
        if str(get_cwl_ica_repo_path().absolute()) in str(relpath(get_cwl_ica_repo_path(), current_path_resolved)):
            # Separate mount point
            expressions_dir = get_cwl_ica_repo_path().absolute()
        else:
            expressions_dir = Path(relpath(get_cwl_ica_repo_path(), current_path_resolved))

    # Now iterate through paths
    for s_path in typescript_expression_paths:
        if current_word_value.endswith("/"):
            print(Path(current_word_value) / expressions_dir.joinpath(s_path))
        else:
            print(Path(current_word_value).parent / expressions_dir.joinpath(s_path))
EOF

 ) )
    compadd -X "typescript_expression_dir:" $__dynamic_completion
}
_cwl-ica_validate-api-key-script_option_project_name_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the project names in the project.yaml file
"""
from cwl_ica.utils.repo import get_project_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each project name
for project in read_yaml(get_project_yaml_path())["projects"]:
    print(project["project_name"])
EOF

 ) )
    compadd -X "project_name:" $__dynamic_completion
}
_cwl-ica_workflow-init_option_workflow_path_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python3

"""
List the unregistered workflow paths
"""

# External imports
from pathlib import Path
from os import getcwd
from os.path import relpath

# CWL ICA imports
from cwl_ica.utils.repo import get_workflow_yaml_path
from cwl_ica.utils.repo import get_workflows_dir
from cwl_ica.utils.miscell import read_yaml


registered_workflow_paths = [
    Path(workflow["path"]) / Path(version["path"])
    for workflow in read_yaml(get_workflow_yaml_path())["workflows"]
    for version in workflow["versions"]
]

# Get the current word value
if not "${CURRENT_WORD}" == "":
    current_word_value = "${CURRENT_WORD}"
else:
    current_word_value = None

# Resolve the current path
# If getcwd() is "/c/Users/awluc"
# 1. Non relative paths: current_word_value = "/etc" -> current_path_resolved = "/etc"
# 2. Relative parent path: current_word_value = "../../Program Files" -> current_path_resolved = "/c/Program Files"
# 3. Subfolder: current_word_value = "OneDrive" -> current_path_resolved = "/c/Users/awluc/OneDrive"
# 4. Subfolder of workflows dir = "OneDrive/GitHub/UMCCR/workflows/contig/" -> current path resolved
if current_word_value is not None:
    if current_word_value.endswith("/"):
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value)).resolve()
    else:
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value).parent).resolve()
else:
    current_word_value = ""
    current_path_resolved = Path(getcwd()).absolute()

# Is the current_path_resolved a subpath of the workflows directory?
try:
    _ = current_path_resolved.relative_to(get_workflows_dir())
    in_workflows_dir = True
except ValueError:
    in_workflows_dir = False

if not current_word_value == "" and in_workflows_dir:
    all_paths = [
        s_file.relative_to(get_workflows_dir())
        for s_file in current_path_resolved.glob("**/*.cwl")
    ]
else:
    all_paths = [
        s_file.relative_to(get_workflows_dir())
        for s_file in get_workflows_dir().glob("**/*.cwl")
    ]

workflow_paths = [
    a_path
    for a_path in all_paths
    if a_path not in registered_workflow_paths
]

if in_workflows_dir:
    current_path_resolved_relative_to_workflows_dir = current_path_resolved.relative_to(get_workflows_dir())
    if current_path_resolved_relative_to_workflows_dir == Path("."):
        for s_path in workflow_paths:
            if current_word_value.endswith("/"):
                print(Path(current_word_value) / s_path)
            else:
                print(Path(current_word_value).parent / s_path)
    else:
        for s_path in workflow_paths:
            if str(s_path).startswith(str(current_path_resolved_relative_to_workflows_dir)):
                if current_word_value.endswith("/"):
                    print(
                        Path(current_word_value) / s_path.relative_to(current_path_resolved_relative_to_workflows_dir))
                else:
                    print(Path(current_word_value).parent / s_path.relative_to(
                        current_path_resolved_relative_to_workflows_dir))

else:
    # Now get the workflows yaml path relative to the current path
    try:
        workflows_dir = get_workflows_dir().relative_to(current_path_resolved)
    except ValueError:
        # We could be in a different mount point OR just in a subdirectory
        if str(get_workflows_dir().absolute()) in str(relpath(get_workflows_dir(), current_path_resolved)):
            # Separate mount point
            workflows_dir = get_workflows_dir().absolute()
        else:
            workflows_dir = Path(relpath(get_workflows_dir(), current_path_resolved))

    # Now iterate through paths
    for s_path in workflow_paths:
        if current_word_value.endswith("/"):
            print(Path(current_word_value) / workflows_dir.joinpath(s_path))
        else:
            print(Path(current_word_value).parent / workflows_dir.joinpath(s_path))
EOF

 ) )
    compadd -X "workflow_path:" $__dynamic_completion
}
_cwl-ica_workflow-init_option_projects_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the project names in the project.yaml file
"""
from cwl_ica.utils.repo import get_project_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each project name
for project in read_yaml(get_project_yaml_path())["projects"]:
    print(project["project_name"])
EOF

 ) )
    compadd -X "projects:" $__dynamic_completion
}
_cwl-ica_workflow-init_option_tenants_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

# CWL ICA imports
from cwl_ica.utils.repo import get_tenant_yaml_path
from cwl_ica.utils.miscell import read_yaml

for tenant in read_yaml(get_tenant_yaml_path())["tenants"]:
    print(tenant["tenant_name"])
EOF

 ) )
    compadd -X "tenants:" $__dynamic_completion
}
_cwl-ica_workflow-init_option_categories_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the category names in the categories.yaml file
"""
from cwl_ica.utils.repo import get_category_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each project name
for category in read_yaml(get_category_yaml_path())["categories"]:
    print(category["name"])
EOF

 ) )
    compadd -X "categories:" $__dynamic_completion
}
_cwl-ica_workflow-sync_option_workflow_path_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python3

"""
List the registered workflow paths
"""

# External imports
from pathlib import Path
from os import getcwd
from os.path import relpath

# CWL ICA
from cwl_ica.utils.repo import get_workflow_yaml_path
from cwl_ica.utils.repo import get_workflows_dir
from cwl_ica.utils.miscell import read_yaml

workflow_paths = [
    Path(workflow["path"]) / Path(version["path"])
    for workflow in read_yaml(get_workflow_yaml_path())["workflows"]
    for version in workflow["versions"]
]

# Get the current word value
if not "${CURRENT_WORD}" == "":
    current_word_value = "${CURRENT_WORD}"
else:
    current_word_value = None

# Resolve the current path
# If getcwd() is "/c/Users/awluc"
# 1. Non relative paths: current_word_value = "/etc" -> current_path_resolved = "/etc"
# 2. Relative parent path: current_word_value = "../../Program Files" -> current_path_resolved = "/c/Program Files"
# 3. Subfolder: current_word_value = "OneDrive" -> current_path_resolved = "/c/Users/awluc/OneDrive"
# 4. Subfolder of workflows dir = "OneDrive/GitHub/UMCCR/workflows/contig/" -> current path resolved
if current_word_value is not None:
    if current_word_value.endswith("/"):
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value)).resolve()
    else:
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value).parent).resolve()

else:
    current_word_value = ""
    current_path_resolved = Path(getcwd()).absolute()

# Is the current_path_resolved a subpath of the workflows directory?
try:
    _ = current_path_resolved.relative_to(get_workflows_dir())
    in_workflows_dir = True
except ValueError:
    in_workflows_dir = False

if in_workflows_dir:
    current_path_resolved_relative_to_workflows_dir = current_path_resolved.relative_to(get_workflows_dir())
    if current_path_resolved_relative_to_workflows_dir == Path("."):
        for s_path in workflow_paths:
            if current_word_value.endswith("/"):
                print(Path(current_word_value) / s_path)
            else:
                print(Path(current_word_value).parent / s_path)
    else:
        for s_path in workflow_paths:
            if str(s_path).startswith(str(current_path_resolved_relative_to_workflows_dir)):
                if current_word_value.endswith("/"):
                    print(
                        Path(current_word_value) / s_path.relative_to(current_path_resolved_relative_to_workflows_dir))
                else:
                    print(Path(current_word_value).parent / s_path.relative_to(
                        current_path_resolved_relative_to_workflows_dir))

else:
    # Now get the workflows yaml path relative to the current path
    try:
        workflows_dir = get_workflows_dir().relative_to(current_path_resolved)
    except ValueError:
        # We could be in a different mount point OR just in a subdirectory
        if str(get_workflows_dir().absolute()) in str(relpath(get_workflows_dir(), current_path_resolved)):
            # Separate mount point
            workflows_dir = get_workflows_dir().absolute()
        else:
            workflows_dir = Path(relpath(get_workflows_dir(), current_path_resolved))

    # Now iterate through paths
    for s_path in workflow_paths:
        if current_word_value.endswith("/"):
            print(Path(current_word_value) / workflows_dir.joinpath(s_path))
        else:
            print(Path(current_word_value).parent / workflows_dir.joinpath(s_path))
EOF

 ) )
    compadd -X "workflow_path:" $__dynamic_completion
}
_cwl-ica_workflow-sync_option_projects_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

"""
List all of the project names in the project.yaml file
"""
from cwl_ica.utils.repo import get_project_yaml_path
from cwl_ica.utils.miscell import read_yaml

# Import yaml and print each project name
for project in read_yaml(get_project_yaml_path())["projects"]:
    print(project["project_name"])
EOF

 ) )
    compadd -X "projects:" $__dynamic_completion
}
_cwl-ica_workflow-sync_option_tenants_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python

# CWL ICA imports
from cwl_ica.utils.repo import get_tenant_yaml_path
from cwl_ica.utils.miscell import read_yaml

for tenant in read_yaml(get_tenant_yaml_path())["tenants"]:
    print(tenant["tenant_name"])
EOF

 ) )
    compadd -X "tenants:" $__dynamic_completion
}
_cwl-ica_workflow-validate_option_workflow_path_completion() {
    local __dynamic_completion
    local CURRENT_WORD="$words[CURRENT]"
    IFS=$'\n' __dynamic_completion=( $( 
python - <<EOF
#!/usr/bin/env python3

"""
List the unregistered workflow paths
"""

# Externals
from pathlib import Path
from os import getcwd
from os.path import relpath

# CWL ICA
from cwl_ica.utils.repo import get_workflows_dir

# Get the current word value
if not "${CURRENT_WORD}" == "":
    current_word_value = "${CURRENT_WORD}"
else:
    current_word_value = None

# Resolve the current path
# If getcwd() is "/c/Users/awluc"
# 1. Non relative paths: current_word_value = "/etc" -> current_path_resolved = "/etc"
# 2. Relative parent path: current_word_value = "../../Program Files" -> current_path_resolved = "/c/Program Files"
# 3. Subfolder: current_word_value = "OneDrive" -> current_path_resolved = "/c/Users/awluc/OneDrive"
# 4. Subfolder of workflows dir = "OneDrive/GitHub/UMCCR/workflows/contig/" -> current path resolved
if current_word_value is not None:
    if current_word_value.endswith("/"):
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value)).resolve()
    else:
        current_path_resolved = Path(getcwd()).joinpath(Path(current_word_value).parent).resolve()
else:
    current_word_value = ""
    current_path_resolved = Path(getcwd()).absolute()


# Is the current_path_resolved a subpath of the workflows directory?
try:
    _ = current_path_resolved.relative_to(get_workflows_dir())
    in_workflows_dir = True
except ValueError:
    in_workflows_dir = False

if not current_word_value == "" and in_workflows_dir:
    workflow_paths = [
        s_file.relative_to(get_workflows_dir())
        for s_file in current_path_resolved.glob("**/*.cwl")
    ]
else:
    workflow_paths = [
        s_file.relative_to(get_workflows_dir())
        for s_file in get_workflows_dir().glob("**/*.cwl")
    ]

if in_workflows_dir:
    current_path_resolved_relative_to_workflows_dir = current_path_resolved.relative_to(get_workflows_dir())
    if current_path_resolved_relative_to_workflows_dir == Path("."):
        for s_path in workflow_paths:
            if current_word_value.endswith("/"):
                print(Path(current_word_value) / s_path)
            else:
                print(Path(current_word_value).parent / s_path)
    else:
        for s_path in workflow_paths:
            if str(s_path).startswith(str(current_path_resolved_relative_to_workflows_dir)):
                if current_word_value.endswith("/"):
                    print(
                        Path(current_word_value) / s_path.relative_to(current_path_resolved_relative_to_workflows_dir))
                else:
                    print(Path(current_word_value).parent / s_path.relative_to(
                        current_path_resolved_relative_to_workflows_dir))

else:
    # Now get the workflows yaml path relative to the current path
    try:
        workflows_dir = get_workflows_dir().relative_to(current_path_resolved)
    except ValueError:
        # We could be in a different mount point OR just in a subdirectory
        if str(get_workflows_dir().absolute()) in str(relpath(get_workflows_dir(), current_path_resolved)):
            # Separate mount point
            workflows_dir = get_workflows_dir().absolute()
        else:
            workflows_dir = Path(relpath(get_workflows_dir(), current_path_resolved))

    # Now iterate through paths
    for s_path in workflow_paths:
        if current_word_value.endswith("/"):
            print(Path(current_word_value) / workflows_dir.joinpath(s_path))
        else:
            print(Path(current_word_value).parent / workflows_dir.joinpath(s_path))
EOF

 ) )
    compadd -X "workflow_path:" $__dynamic_completion
}

__cwl-ica_dynamic_comp() {
    local argname="$1"
    local arg="$2"
    local comp="arg:$argname:(("
    local line
    while read -r line; do
        local name="$line"
        local desc="$line"
        name="${name%$'\t'*}"
        desc="${desc/*$'\t'}"
        comp="$comp$name"
        if [[ -n "$desc" && "$name" != "$desc" ]]; then
            comp="$comp\\:"'"'"$desc"'"'
        fi
        comp="$comp "
    done <<< "$arg"

    comp="$comp))"
    _alternative "$comp"
}

